/* tslint:disable */
/* eslint-disable */
/**
 * TeamCity REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2018.1 (current)
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  type RequestArgs,
  RequiredError,
  operationServerMap,
} from '../base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from '../common';
import type { Configuration } from '../configuration';
// @ts-ignore
import type { Cleanup } from '../models';
// @ts-ignore
import type { Files } from '../models';
// @ts-ignore
import type { LicenseKey } from '../models';
// @ts-ignore
import type { LicenseKeys } from '../models';
// @ts-ignore
import type { LicensingData } from '../models';
// @ts-ignore
import type { Metrics } from '../models';
// @ts-ignore
import type { Plugins } from '../models';
// @ts-ignore
import type { Server } from '../models';

/**
 * ServerApi - axios parameter creator
 * @export
 */
export const ServerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add license keys.
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLicenseKeys: async (
      fields?: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server/licensingData/licenseKeys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a license key.
     * @param {string} licenseKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLicenseKey: async (
      licenseKey: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'licenseKey' is not null or undefined
      assertParamExists('deleteLicenseKey', 'licenseKey', licenseKey);
      const localVarPath = `/app/rest/server/licensingData/licenseKeys/{licenseKey}`.replace(
        `{${'licenseKey'}}`,
        encodeURIComponent(String(licenseKey))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download specific file.
     * @param {string} path
     * @param {string} areaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFileOfServer: async (
      path: string,
      areaId: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('downloadFileOfServer', 'path', path);
      // verify required parameter 'areaId' is not null or undefined
      assertParamExists('downloadFileOfServer', 'areaId', areaId);
      const localVarPath = `/app/rest/server/files/{areaId}/files{path}`
        .replace(`{${'path'}}`, encodeURIComponent(String(path)))
        .replace(`{${'areaId'}}`, encodeURIComponent(String(areaId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get metrics.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMetrics: async (
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server/metrics`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all plugins.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPlugins: async (
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server/plugins`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the latest backup status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBackupStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server/backup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get clean-up settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCleanupSettings: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server/cleanup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get metadata of specific file.
     * @param {string} path
     * @param {string} areaId
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadataOfServer: async (
      path: string,
      areaId: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getFileMetadataOfServer', 'path', path);
      // verify required parameter 'areaId' is not null or undefined
      assertParamExists('getFileMetadataOfServer', 'areaId', areaId);
      const localVarPath = `/app/rest/server/files/{areaId}/metadata{path}`
        .replace(`{${'path'}}`, encodeURIComponent(String(path)))
        .replace(`{${'areaId'}}`, encodeURIComponent(String(areaId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List files under this path.
     * @param {string} path
     * @param {string} areaId
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListForSubpathOfServer: async (
      path: string,
      areaId: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getFilesListForSubpathOfServer', 'path', path);
      // verify required parameter 'areaId' is not null or undefined
      assertParamExists('getFilesListForSubpathOfServer', 'areaId', areaId);
      const localVarPath = `/app/rest/server/files/{areaId}/{path}`
        .replace(`{${'path'}}`, encodeURIComponent(String(path)))
        .replace(`{${'areaId'}}`, encodeURIComponent(String(areaId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (basePath !== undefined) {
        localVarQueryParameter['basePath'] = String(basePath);
      }

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all files.
     * @param {string} areaId
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListOfServer: async (
      areaId: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'areaId' is not null or undefined
      assertParamExists('getFilesListOfServer', 'areaId', areaId);
      const localVarPath = `/app/rest/server/files/{areaId}`.replace(
        `{${'areaId'}}`,
        encodeURIComponent(String(areaId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (basePath !== undefined) {
        localVarQueryParameter['basePath'] = String(basePath);
      }

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a license key.
     * @param {string} licenseKey
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenseKey: async (
      licenseKey: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'licenseKey' is not null or undefined
      assertParamExists('getLicenseKey', 'licenseKey', licenseKey);
      const localVarPath = `/app/rest/server/licensingData/licenseKeys/{licenseKey}`.replace(
        `{${'licenseKey'}}`,
        encodeURIComponent(String(licenseKey))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all license keys.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenseKeys: async (
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server/licensingData/licenseKeys`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the licensing data.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicensingData: async (
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server/licensingData`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a field of the server info.
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerField: async (
      field: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'field' is not null or undefined
      assertParamExists('getServerField', 'field', field);
      const localVarPath = `/app/rest/server/{field}`.replace(
        `{${'field'}}`,
        encodeURIComponent(String(field))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the server info.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo: async (
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get specific file zipped.
     * @param {string} path
     * @param {string} areaId
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getZippedFileOfServer: async (
      path: string,
      areaId: string,
      basePath?: string,
      locator?: string,
      name?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getZippedFileOfServer', 'path', path);
      // verify required parameter 'areaId' is not null or undefined
      assertParamExists('getZippedFileOfServer', 'areaId', areaId);
      const localVarPath = `/app/rest/server/files/{areaId}/archived{path}`
        .replace(`{${'path'}}`, encodeURIComponent(String(path)))
        .replace(`{${'areaId'}}`, encodeURIComponent(String(areaId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (basePath !== undefined) {
        localVarQueryParameter['basePath'] = String(basePath);
      }

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = String(name);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Set clean-up settings.
     * @param {Cleanup} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCleanupSettings: async (
      body?: Cleanup,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server/cleanup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Start a new backup.
     * @param {string} [fileName]
     * @param {boolean} [addTimestamp]
     * @param {boolean} [includeConfigs]
     * @param {boolean} [includeDatabase]
     * @param {boolean} [includeBuildLogs]
     * @param {boolean} [includePersonalChanges]
     * @param {boolean} [includeRunningBuilds]
     * @param {boolean} [includeSupplimentaryData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startBackup: async (
      fileName?: string,
      addTimestamp?: boolean,
      includeConfigs?: boolean,
      includeDatabase?: boolean,
      includeBuildLogs?: boolean,
      includePersonalChanges?: boolean,
      includeRunningBuilds?: boolean,
      includeSupplimentaryData?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/server/backup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fileName !== undefined) {
        localVarQueryParameter['fileName'] = String(fileName);
      }

      if (addTimestamp !== undefined) {
        localVarQueryParameter['addTimestamp'] = String(addTimestamp);
      }

      if (includeConfigs !== undefined) {
        localVarQueryParameter['includeConfigs'] = String(includeConfigs);
      }

      if (includeDatabase !== undefined) {
        localVarQueryParameter['includeDatabase'] = String(includeDatabase);
      }

      if (includeBuildLogs !== undefined) {
        localVarQueryParameter['includeBuildLogs'] = String(includeBuildLogs);
      }

      if (includePersonalChanges !== undefined) {
        localVarQueryParameter['includePersonalChanges'] = String(includePersonalChanges);
      }

      if (includeRunningBuilds !== undefined) {
        localVarQueryParameter['includeRunningBuilds'] = String(includeRunningBuilds);
      }

      if (includeSupplimentaryData !== undefined) {
        localVarQueryParameter['includeSupplimentaryData'] = String(includeSupplimentaryData);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ServerApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Add license keys.
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addLicenseKeys(
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseKeys>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addLicenseKeys(
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.addLicenseKeys']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a license key.
     * @param {string} licenseKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLicenseKey(
      licenseKey: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLicenseKey(
        licenseKey,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.deleteLicenseKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download specific file.
     * @param {string} path
     * @param {string} areaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFileOfServer(
      path: string,
      areaId: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFileOfServer(
        path,
        areaId,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.downloadFileOfServer']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get metrics.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllMetrics(
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metrics>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMetrics(fields, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getAllMetrics']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all plugins.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllPlugins(
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plugins>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPlugins(fields, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getAllPlugins']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the latest backup status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBackupStatus(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBackupStatus(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getBackupStatus']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get clean-up settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCleanupSettings(
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cleanup>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCleanupSettings(options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getCleanupSettings']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get metadata of specific file.
     * @param {string} path
     * @param {string} areaId
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileMetadataOfServer(
      path: string,
      areaId: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileMetadataOfServer(
        path,
        areaId,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getFileMetadataOfServer']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List files under this path.
     * @param {string} path
     * @param {string} areaId
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilesListForSubpathOfServer(
      path: string,
      areaId: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Files>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesListForSubpathOfServer(
        path,
        areaId,
        basePath,
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getFilesListForSubpathOfServer']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List all files.
     * @param {string} areaId
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilesListOfServer(
      areaId: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Files>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesListOfServer(
        areaId,
        basePath,
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getFilesListOfServer']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a license key.
     * @param {string} licenseKey
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLicenseKey(
      licenseKey: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseKey>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseKey(
        licenseKey,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getLicenseKey']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all license keys.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLicenseKeys(
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseKeys>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseKeys(fields, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getLicenseKeys']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the licensing data.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLicensingData(
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicensingData>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLicensingData(fields, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getLicensingData']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a field of the server info.
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServerField(
      field: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServerField(field, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getServerField']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the server info.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getServerInfo(
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Server>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(fields, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getServerInfo']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get specific file zipped.
     * @param {string} path
     * @param {string} areaId
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getZippedFileOfServer(
      path: string,
      areaId: string,
      basePath?: string,
      locator?: string,
      name?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getZippedFileOfServer(
        path,
        areaId,
        basePath,
        locator,
        name,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.getZippedFileOfServer']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Set clean-up settings.
     * @param {Cleanup} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setCleanupSettings(
      body?: Cleanup,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cleanup>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setCleanupSettings(body, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.setCleanupSettings']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Start a new backup.
     * @param {string} [fileName]
     * @param {boolean} [addTimestamp]
     * @param {boolean} [includeConfigs]
     * @param {boolean} [includeDatabase]
     * @param {boolean} [includeBuildLogs]
     * @param {boolean} [includePersonalChanges]
     * @param {boolean} [includeRunningBuilds]
     * @param {boolean} [includeSupplimentaryData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async startBackup(
      fileName?: string,
      addTimestamp?: boolean,
      includeConfigs?: boolean,
      includeDatabase?: boolean,
      includeBuildLogs?: boolean,
      includePersonalChanges?: boolean,
      includeRunningBuilds?: boolean,
      includeSupplimentaryData?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.startBackup(
        fileName,
        addTimestamp,
        includeConfigs,
        includeDatabase,
        includeBuildLogs,
        includePersonalChanges,
        includeRunningBuilds,
        includeSupplimentaryData,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['ServerApi.startBackup']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ServerApiFp(configuration);
  return {
    /**
     *
     * @summary Add license keys.
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLicenseKeys(
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<LicenseKeys> {
      return localVarFp
        .addLicenseKeys(fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a license key.
     * @param {string} licenseKey
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLicenseKey(licenseKey: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .deleteLicenseKey(licenseKey, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Download specific file.
     * @param {string} path
     * @param {string} areaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFileOfServer(
      path: string,
      areaId: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .downloadFileOfServer(path, areaId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get metrics.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllMetrics(fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<Metrics> {
      return localVarFp.getAllMetrics(fields, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all plugins.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllPlugins(fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<Plugins> {
      return localVarFp.getAllPlugins(fields, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the latest backup status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBackupStatus(options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.getBackupStatus(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get clean-up settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCleanupSettings(options?: RawAxiosRequestConfig): AxiosPromise<Cleanup> {
      return localVarFp.getCleanupSettings(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get metadata of specific file.
     * @param {string} path
     * @param {string} areaId
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadataOfServer(
      path: string,
      areaId: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .getFileMetadataOfServer(path, areaId, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List files under this path.
     * @param {string} path
     * @param {string} areaId
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListForSubpathOfServer(
      path: string,
      areaId: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Files> {
      return localVarFp
        .getFilesListForSubpathOfServer(path, areaId, basePath, locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all files.
     * @param {string} areaId
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListOfServer(
      areaId: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Files> {
      return localVarFp
        .getFilesListOfServer(areaId, basePath, locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a license key.
     * @param {string} licenseKey
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenseKey(
      licenseKey: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<LicenseKey> {
      return localVarFp
        .getLicenseKey(licenseKey, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all license keys.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenseKeys(fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<LicenseKeys> {
      return localVarFp.getLicenseKeys(fields, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the licensing data.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicensingData(
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<LicensingData> {
      return localVarFp
        .getLicensingData(fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a field of the server info.
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerField(field: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp.getServerField(field, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the server info.
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getServerInfo(fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<Server> {
      return localVarFp.getServerInfo(fields, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get specific file zipped.
     * @param {string} path
     * @param {string} areaId
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getZippedFileOfServer(
      path: string,
      areaId: string,
      basePath?: string,
      locator?: string,
      name?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .getZippedFileOfServer(path, areaId, basePath, locator, name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Set clean-up settings.
     * @param {Cleanup} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCleanupSettings(body?: Cleanup, options?: RawAxiosRequestConfig): AxiosPromise<Cleanup> {
      return localVarFp
        .setCleanupSettings(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Start a new backup.
     * @param {string} [fileName]
     * @param {boolean} [addTimestamp]
     * @param {boolean} [includeConfigs]
     * @param {boolean} [includeDatabase]
     * @param {boolean} [includeBuildLogs]
     * @param {boolean} [includePersonalChanges]
     * @param {boolean} [includeRunningBuilds]
     * @param {boolean} [includeSupplimentaryData]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    startBackup(
      fileName?: string,
      addTimestamp?: boolean,
      includeConfigs?: boolean,
      includeDatabase?: boolean,
      includeBuildLogs?: boolean,
      includePersonalChanges?: boolean,
      includeRunningBuilds?: boolean,
      includeSupplimentaryData?: boolean,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .startBackup(
          fileName,
          addTimestamp,
          includeConfigs,
          includeDatabase,
          includeBuildLogs,
          includePersonalChanges,
          includeRunningBuilds,
          includeSupplimentaryData,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ServerApi - interface
 * @export
 * @interface ServerApi
 */
export interface ServerApiInterface {
  /**
   *
   * @summary Add license keys.
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  addLicenseKeys(
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<LicenseKeys>;

  /**
   *
   * @summary Delete a license key.
   * @param {string} licenseKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  deleteLicenseKey(licenseKey: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @summary Download specific file.
   * @param {string} path
   * @param {string} areaId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  downloadFileOfServer(
    path: string,
    areaId: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get metrics.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getAllMetrics(fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<Metrics>;

  /**
   *
   * @summary Get all plugins.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getAllPlugins(fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<Plugins>;

  /**
   *
   * @summary Get the latest backup status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getBackupStatus(options?: RawAxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @summary Get clean-up settings.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getCleanupSettings(options?: RawAxiosRequestConfig): AxiosPromise<Cleanup>;

  /**
   *
   * @summary Get metadata of specific file.
   * @param {string} path
   * @param {string} areaId
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getFileMetadataOfServer(
    path: string,
    areaId: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<any>;

  /**
   *
   * @summary List files under this path.
   * @param {string} path
   * @param {string} areaId
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getFilesListForSubpathOfServer(
    path: string,
    areaId: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Files>;

  /**
   *
   * @summary List all files.
   * @param {string} areaId
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getFilesListOfServer(
    areaId: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Files>;

  /**
   *
   * @summary Get a license key.
   * @param {string} licenseKey
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getLicenseKey(
    licenseKey: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<LicenseKey>;

  /**
   *
   * @summary Get all license keys.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getLicenseKeys(fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<LicenseKeys>;

  /**
   *
   * @summary Get the licensing data.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getLicensingData(fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<LicensingData>;

  /**
   *
   * @summary Get a field of the server info.
   * @param {string} field
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getServerField(field: string, options?: RawAxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @summary Get the server info.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getServerInfo(fields?: string, options?: RawAxiosRequestConfig): AxiosPromise<Server>;

  /**
   *
   * @summary Get specific file zipped.
   * @param {string} path
   * @param {string} areaId
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  getZippedFileOfServer(
    path: string,
    areaId: string,
    basePath?: string,
    locator?: string,
    name?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Set clean-up settings.
   * @param {Cleanup} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  setCleanupSettings(body?: Cleanup, options?: RawAxiosRequestConfig): AxiosPromise<Cleanup>;

  /**
   *
   * @summary Start a new backup.
   * @param {string} [fileName]
   * @param {boolean} [addTimestamp]
   * @param {boolean} [includeConfigs]
   * @param {boolean} [includeDatabase]
   * @param {boolean} [includeBuildLogs]
   * @param {boolean} [includePersonalChanges]
   * @param {boolean} [includeRunningBuilds]
   * @param {boolean} [includeSupplimentaryData]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApiInterface
   */
  startBackup(
    fileName?: string,
    addTimestamp?: boolean,
    includeConfigs?: boolean,
    includeDatabase?: boolean,
    includeBuildLogs?: boolean,
    includePersonalChanges?: boolean,
    includeRunningBuilds?: boolean,
    includeSupplimentaryData?: boolean,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;
}

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI implements ServerApiInterface {
  /**
   *
   * @summary Add license keys.
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public addLicenseKeys(fields?: string, body?: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .addLicenseKeys(fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a license key.
   * @param {string} licenseKey
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public deleteLicenseKey(licenseKey: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .deleteLicenseKey(licenseKey, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download specific file.
   * @param {string} path
   * @param {string} areaId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public downloadFileOfServer(path: string, areaId: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .downloadFileOfServer(path, areaId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get metrics.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getAllMetrics(fields?: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getAllMetrics(fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all plugins.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getAllPlugins(fields?: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getAllPlugins(fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the latest backup status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getBackupStatus(options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getBackupStatus(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get clean-up settings.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getCleanupSettings(options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getCleanupSettings(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get metadata of specific file.
   * @param {string} path
   * @param {string} areaId
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getFileMetadataOfServer(
    path: string,
    areaId: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ServerApiFp(this.configuration)
      .getFileMetadataOfServer(path, areaId, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List files under this path.
   * @param {string} path
   * @param {string} areaId
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getFilesListForSubpathOfServer(
    path: string,
    areaId: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ServerApiFp(this.configuration)
      .getFilesListForSubpathOfServer(path, areaId, basePath, locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all files.
   * @param {string} areaId
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getFilesListOfServer(
    areaId: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ServerApiFp(this.configuration)
      .getFilesListOfServer(areaId, basePath, locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a license key.
   * @param {string} licenseKey
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getLicenseKey(licenseKey: string, fields?: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getLicenseKey(licenseKey, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all license keys.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getLicenseKeys(fields?: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getLicenseKeys(fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the licensing data.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getLicensingData(fields?: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getLicensingData(fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a field of the server info.
   * @param {string} field
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getServerField(field: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getServerField(field, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the server info.
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getServerInfo(fields?: string, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .getServerInfo(fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get specific file zipped.
   * @param {string} path
   * @param {string} areaId
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public getZippedFileOfServer(
    path: string,
    areaId: string,
    basePath?: string,
    locator?: string,
    name?: string,
    options?: RawAxiosRequestConfig
  ) {
    return ServerApiFp(this.configuration)
      .getZippedFileOfServer(path, areaId, basePath, locator, name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Set clean-up settings.
   * @param {Cleanup} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public setCleanupSettings(body?: Cleanup, options?: RawAxiosRequestConfig) {
    return ServerApiFp(this.configuration)
      .setCleanupSettings(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Start a new backup.
   * @param {string} [fileName]
   * @param {boolean} [addTimestamp]
   * @param {boolean} [includeConfigs]
   * @param {boolean} [includeDatabase]
   * @param {boolean} [includeBuildLogs]
   * @param {boolean} [includePersonalChanges]
   * @param {boolean} [includeRunningBuilds]
   * @param {boolean} [includeSupplimentaryData]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ServerApi
   */
  public startBackup(
    fileName?: string,
    addTimestamp?: boolean,
    includeConfigs?: boolean,
    includeDatabase?: boolean,
    includeBuildLogs?: boolean,
    includePersonalChanges?: boolean,
    includeRunningBuilds?: boolean,
    includeSupplimentaryData?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return ServerApiFp(this.configuration)
      .startBackup(
        fileName,
        addTimestamp,
        includeConfigs,
        includeDatabase,
        includeBuildLogs,
        includePersonalChanges,
        includeRunningBuilds,
        includeSupplimentaryData,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
