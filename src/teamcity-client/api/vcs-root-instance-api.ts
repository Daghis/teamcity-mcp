/* tslint:disable */
/* eslint-disable */
/**
 * TeamCity REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2018.1 (current)
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  type RequestArgs,
  RequiredError,
  operationServerMap,
} from '../base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from '../common';
import type { Configuration } from '../configuration';
// @ts-ignore
import type { Entries } from '../models';
// @ts-ignore
import type { Files } from '../models';
// @ts-ignore
import type { Properties } from '../models';
// @ts-ignore
import type { VcsRootInstance } from '../models';
// @ts-ignore
import type { VcsRootInstances } from '../models';

/**
 * VcsRootInstanceApi - axios parameter creator
 * @export
 */
export const VcsRootInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Remove a field of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVcsRootInstanceField: async (
      vcsRootInstanceLocator: string,
      field: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists(
        'deleteVcsRootInstanceField',
        'vcsRootInstanceLocator',
        vcsRootInstanceLocator
      );
      // verify required parameter 'field' is not null or undefined
      assertParamExists('deleteVcsRootInstanceField', 'field', field);
      const localVarPath = `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/{field}`
        .replace(
          `{${'vcsRootInstanceLocator'}}`,
          encodeURIComponent(String(vcsRootInstanceLocator))
        )
        .replace(`{${'field'}}`, encodeURIComponent(String(field)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete the last repository state of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVcsRootInstanceRepositoryState: async (
      vcsRootInstanceLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists(
        'deleteVcsRootInstanceRepositoryState',
        'vcsRootInstanceLocator',
        vcsRootInstanceLocator
      );
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/repositoryState`.replace(
          `{${'vcsRootInstanceLocator'}}`,
          encodeURIComponent(String(vcsRootInstanceLocator))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download specific file.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile: async (
      path: string,
      vcsRootInstanceLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('downloadFile', 'path', path);
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists('downloadFile', 'vcsRootInstanceLocator', vcsRootInstanceLocator);
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest/files{path}`
          .replace(`{${'path'}}`, encodeURIComponent(String(path)))
          .replace(
            `{${'vcsRootInstanceLocator'}}`,
            encodeURIComponent(String(vcsRootInstanceLocator))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all VCS root instances.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVcsRootInstances: async (
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/vcs-root-instances`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get metadata of specific file.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadata: async (
      path: string,
      vcsRootInstanceLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getFileMetadata', 'path', path);
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists('getFileMetadata', 'vcsRootInstanceLocator', vcsRootInstanceLocator);
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest/metadata{path}`
          .replace(`{${'path'}}`, encodeURIComponent(String(path)))
          .replace(
            `{${'vcsRootInstanceLocator'}}`,
            encodeURIComponent(String(vcsRootInstanceLocator))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all files.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesList: async (
      vcsRootInstanceLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists('getFilesList', 'vcsRootInstanceLocator', vcsRootInstanceLocator);
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest`.replace(
          `{${'vcsRootInstanceLocator'}}`,
          encodeURIComponent(String(vcsRootInstanceLocator))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (basePath !== undefined) {
        localVarQueryParameter['basePath'] = String(basePath);
      }

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List files under this path.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListForSubpath: async (
      path: string,
      vcsRootInstanceLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getFilesListForSubpath', 'path', path);
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists('getFilesListForSubpath', 'vcsRootInstanceLocator', vcsRootInstanceLocator);
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest/{path}`
          .replace(`{${'path'}}`, encodeURIComponent(String(path)))
          .replace(
            `{${'vcsRootInstanceLocator'}}`,
            encodeURIComponent(String(vcsRootInstanceLocator))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (basePath !== undefined) {
        localVarQueryParameter['basePath'] = String(basePath);
      }

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get VCS root instance matching the locator.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstance: async (
      vcsRootInstanceLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists('getVcsRootInstance', 'vcsRootInstanceLocator', vcsRootInstanceLocator);
      const localVarPath = `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}`.replace(
        `{${'vcsRootInstanceLocator'}}`,
        encodeURIComponent(String(vcsRootInstanceLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the creation date of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstanceCreationDate: async (
      vcsRootInstanceLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists(
        'getVcsRootInstanceCreationDate',
        'vcsRootInstanceLocator',
        vcsRootInstanceLocator
      );
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/repositoryState/creationDate`.replace(
          `{${'vcsRootInstanceLocator'}}`,
          encodeURIComponent(String(vcsRootInstanceLocator))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a field of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstanceField: async (
      vcsRootInstanceLocator: string,
      field: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists(
        'getVcsRootInstanceField',
        'vcsRootInstanceLocator',
        vcsRootInstanceLocator
      );
      // verify required parameter 'field' is not null or undefined
      assertParamExists('getVcsRootInstanceField', 'field', field);
      const localVarPath = `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/{field}`
        .replace(
          `{${'vcsRootInstanceLocator'}}`,
          encodeURIComponent(String(vcsRootInstanceLocator))
        )
        .replace(`{${'field'}}`, encodeURIComponent(String(field)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all properties of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstanceProperties: async (
      vcsRootInstanceLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists(
        'getVcsRootInstanceProperties',
        'vcsRootInstanceLocator',
        vcsRootInstanceLocator
      );
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/properties`.replace(
          `{${'vcsRootInstanceLocator'}}`,
          encodeURIComponent(String(vcsRootInstanceLocator))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the repository state of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstanceRepositoryState: async (
      vcsRootInstanceLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists(
        'getVcsRootInstanceRepositoryState',
        'vcsRootInstanceLocator',
        vcsRootInstanceLocator
      );
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/repositoryState`.replace(
          `{${'vcsRootInstanceLocator'}}`,
          encodeURIComponent(String(vcsRootInstanceLocator))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get specific file zipped.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getZippedFile: async (
      path: string,
      vcsRootInstanceLocator: string,
      basePath?: string,
      locator?: string,
      name?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getZippedFile', 'path', path);
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists('getZippedFile', 'vcsRootInstanceLocator', vcsRootInstanceLocator);
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/files/latest/archived{path}`
          .replace(`{${'path'}}`, encodeURIComponent(String(path)))
          .replace(
            `{${'vcsRootInstanceLocator'}}`,
            encodeURIComponent(String(vcsRootInstanceLocator))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (basePath !== undefined) {
        localVarQueryParameter['basePath'] = String(basePath);
      }

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = String(name);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check for the pending changes for all VCS root instances.
     * @param {string} [locator]
     * @param {string} [requestor]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPendingChangesCheck: async (
      locator?: string,
      requestor?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/vcs-root-instances/checkingForChangesQueue`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (requestor !== undefined) {
        localVarQueryParameter['requestor'] = String(requestor);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a field of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} field
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVcsRootInstanceField: async (
      vcsRootInstanceLocator: string,
      field: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists(
        'setVcsRootInstanceField',
        'vcsRootInstanceLocator',
        vcsRootInstanceLocator
      );
      // verify required parameter 'field' is not null or undefined
      assertParamExists('setVcsRootInstanceField', 'field', field);
      const localVarPath = `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/{field}`
        .replace(
          `{${'vcsRootInstanceLocator'}}`,
          encodeURIComponent(String(vcsRootInstanceLocator))
        )
        .replace(`{${'field'}}`, encodeURIComponent(String(field)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the repository state of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {Entries} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVcsRootInstanceRepositoryState: async (
      vcsRootInstanceLocator: string,
      fields?: string,
      body?: Entries,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'vcsRootInstanceLocator' is not null or undefined
      assertParamExists(
        'setVcsRootInstanceRepositoryState',
        'vcsRootInstanceLocator',
        vcsRootInstanceLocator
      );
      const localVarPath =
        `/app/rest/vcs-root-instances/{vcsRootInstanceLocator}/repositoryState`.replace(
          `{${'vcsRootInstanceLocator'}}`,
          encodeURIComponent(String(vcsRootInstanceLocator))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Send the commit hook notification.
     * @param {string} [locator]
     * @param {boolean} [okOnNothingFound]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    triggerCommitHookNotification: async (
      locator?: string,
      okOnNothingFound?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/vcs-root-instances/commitHookNotification`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (okOnNothingFound !== undefined) {
        localVarQueryParameter['okOnNothingFound'] = String(okOnNothingFound);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * VcsRootInstanceApi - functional programming interface
 * @export
 */
export const VcsRootInstanceApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = VcsRootInstanceApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Remove a field of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteVcsRootInstanceField(
      vcsRootInstanceLocator: string,
      field: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteVcsRootInstanceField(
        vcsRootInstanceLocator,
        field,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.deleteVcsRootInstanceField']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete the last repository state of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteVcsRootInstanceRepositoryState(
      vcsRootInstanceLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteVcsRootInstanceRepositoryState(
          vcsRootInstanceLocator,
          options
        );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.deleteVcsRootInstanceRepositoryState']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download specific file.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFile(
      path: string,
      vcsRootInstanceLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFile(
        path,
        vcsRootInstanceLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.downloadFile']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all VCS root instances.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllVcsRootInstances(
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VcsRootInstances>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllVcsRootInstances(
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getAllVcsRootInstances']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get metadata of specific file.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileMetadata(
      path: string,
      vcsRootInstanceLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileMetadata(
        path,
        vcsRootInstanceLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getFileMetadata']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List all files.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilesList(
      vcsRootInstanceLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Files>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesList(
        vcsRootInstanceLocator,
        basePath,
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getFilesList']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List files under this path.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilesListForSubpath(
      path: string,
      vcsRootInstanceLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Files>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesListForSubpath(
        path,
        vcsRootInstanceLocator,
        basePath,
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getFilesListForSubpath']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get VCS root instance matching the locator.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVcsRootInstance(
      vcsRootInstanceLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VcsRootInstance>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVcsRootInstance(
        vcsRootInstanceLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getVcsRootInstance']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the creation date of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVcsRootInstanceCreationDate(
      vcsRootInstanceLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVcsRootInstanceCreationDate(
        vcsRootInstanceLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getVcsRootInstanceCreationDate']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a field of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVcsRootInstanceField(
      vcsRootInstanceLocator: string,
      field: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVcsRootInstanceField(
        vcsRootInstanceLocator,
        field,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getVcsRootInstanceField']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all properties of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVcsRootInstanceProperties(
      vcsRootInstanceLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Properties>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVcsRootInstanceProperties(
        vcsRootInstanceLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getVcsRootInstanceProperties']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the repository state of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getVcsRootInstanceRepositoryState(
      vcsRootInstanceLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entries>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getVcsRootInstanceRepositoryState(
        vcsRootInstanceLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getVcsRootInstanceRepositoryState']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get specific file zipped.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getZippedFile(
      path: string,
      vcsRootInstanceLocator: string,
      basePath?: string,
      locator?: string,
      name?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getZippedFile(
        path,
        vcsRootInstanceLocator,
        basePath,
        locator,
        name,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.getZippedFile']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Check for the pending changes for all VCS root instances.
     * @param {string} [locator]
     * @param {string} [requestor]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestPendingChangesCheck(
      locator?: string,
      requestor?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VcsRootInstances>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestPendingChangesCheck(
        locator,
        requestor,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.requestPendingChangesCheck']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a field of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} field
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setVcsRootInstanceField(
      vcsRootInstanceLocator: string,
      field: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setVcsRootInstanceField(
        vcsRootInstanceLocator,
        field,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.setVcsRootInstanceField']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update the repository state of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {Entries} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setVcsRootInstanceRepositoryState(
      vcsRootInstanceLocator: string,
      fields?: string,
      body?: Entries,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entries>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setVcsRootInstanceRepositoryState(
        vcsRootInstanceLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.setVcsRootInstanceRepositoryState']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Send the commit hook notification.
     * @param {string} [locator]
     * @param {boolean} [okOnNothingFound]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async triggerCommitHookNotification(
      locator?: string,
      okOnNothingFound?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.triggerCommitHookNotification(
        locator,
        okOnNothingFound,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['VcsRootInstanceApi.triggerCommitHookNotification']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * VcsRootInstanceApi - factory interface
 * @export
 */
export const VcsRootInstanceApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = VcsRootInstanceApiFp(configuration);
  return {
    /**
     *
     * @summary Remove a field of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVcsRootInstanceField(
      vcsRootInstanceLocator: string,
      field: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteVcsRootInstanceField(vcsRootInstanceLocator, field, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete the last repository state of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteVcsRootInstanceRepositoryState(
      vcsRootInstanceLocator: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteVcsRootInstanceRepositoryState(vcsRootInstanceLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Download specific file.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFile(
      path: string,
      vcsRootInstanceLocator: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .downloadFile(path, vcsRootInstanceLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all VCS root instances.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllVcsRootInstances(
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VcsRootInstances> {
      return localVarFp
        .getAllVcsRootInstances(locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get metadata of specific file.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadata(
      path: string,
      vcsRootInstanceLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .getFileMetadata(path, vcsRootInstanceLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all files.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesList(
      vcsRootInstanceLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Files> {
      return localVarFp
        .getFilesList(vcsRootInstanceLocator, basePath, locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List files under this path.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListForSubpath(
      path: string,
      vcsRootInstanceLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Files> {
      return localVarFp
        .getFilesListForSubpath(path, vcsRootInstanceLocator, basePath, locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get VCS root instance matching the locator.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstance(
      vcsRootInstanceLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VcsRootInstance> {
      return localVarFp
        .getVcsRootInstance(vcsRootInstanceLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the creation date of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstanceCreationDate(
      vcsRootInstanceLocator: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getVcsRootInstanceCreationDate(vcsRootInstanceLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a field of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstanceField(
      vcsRootInstanceLocator: string,
      field: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getVcsRootInstanceField(vcsRootInstanceLocator, field, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all properties of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstanceProperties(
      vcsRootInstanceLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Properties> {
      return localVarFp
        .getVcsRootInstanceProperties(vcsRootInstanceLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the repository state of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getVcsRootInstanceRepositoryState(
      vcsRootInstanceLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Entries> {
      return localVarFp
        .getVcsRootInstanceRepositoryState(vcsRootInstanceLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get specific file zipped.
     * @param {string} path
     * @param {string} vcsRootInstanceLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getZippedFile(
      path: string,
      vcsRootInstanceLocator: string,
      basePath?: string,
      locator?: string,
      name?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .getZippedFile(path, vcsRootInstanceLocator, basePath, locator, name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Check for the pending changes for all VCS root instances.
     * @param {string} [locator]
     * @param {string} [requestor]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestPendingChangesCheck(
      locator?: string,
      requestor?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VcsRootInstances> {
      return localVarFp
        .requestPendingChangesCheck(locator, requestor, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a field of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} field
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVcsRootInstanceField(
      vcsRootInstanceLocator: string,
      field: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .setVcsRootInstanceField(vcsRootInstanceLocator, field, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the repository state of the matching VCS root instance.
     * @param {string} vcsRootInstanceLocator
     * @param {string} [fields]
     * @param {Entries} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setVcsRootInstanceRepositoryState(
      vcsRootInstanceLocator: string,
      fields?: string,
      body?: Entries,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Entries> {
      return localVarFp
        .setVcsRootInstanceRepositoryState(vcsRootInstanceLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Send the commit hook notification.
     * @param {string} [locator]
     * @param {boolean} [okOnNothingFound]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    triggerCommitHookNotification(
      locator?: string,
      okOnNothingFound?: boolean,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .triggerCommitHookNotification(locator, okOnNothingFound, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * VcsRootInstanceApi - interface
 * @export
 * @interface VcsRootInstanceApi
 */
export interface VcsRootInstanceApiInterface {
  /**
   *
   * @summary Remove a field of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} field
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  deleteVcsRootInstanceField(
    vcsRootInstanceLocator: string,
    field: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Delete the last repository state of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  deleteVcsRootInstanceRepositoryState(
    vcsRootInstanceLocator: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Download specific file.
   * @param {string} path
   * @param {string} vcsRootInstanceLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  downloadFile(
    path: string,
    vcsRootInstanceLocator: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get all VCS root instances.
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getAllVcsRootInstances(
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<VcsRootInstances>;

  /**
   *
   * @summary Get metadata of specific file.
   * @param {string} path
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getFileMetadata(
    path: string,
    vcsRootInstanceLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<any>;

  /**
   *
   * @summary List all files.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getFilesList(
    vcsRootInstanceLocator: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Files>;

  /**
   *
   * @summary List files under this path.
   * @param {string} path
   * @param {string} vcsRootInstanceLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getFilesListForSubpath(
    path: string,
    vcsRootInstanceLocator: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Files>;

  /**
   *
   * @summary Get VCS root instance matching the locator.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getVcsRootInstance(
    vcsRootInstanceLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<VcsRootInstance>;

  /**
   *
   * @summary Get the creation date of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getVcsRootInstanceCreationDate(
    vcsRootInstanceLocator: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Get a field of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} field
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getVcsRootInstanceField(
    vcsRootInstanceLocator: string,
    field: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Get all properties of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getVcsRootInstanceProperties(
    vcsRootInstanceLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Properties>;

  /**
   *
   * @summary Get the repository state of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getVcsRootInstanceRepositoryState(
    vcsRootInstanceLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Entries>;

  /**
   *
   * @summary Get specific file zipped.
   * @param {string} path
   * @param {string} vcsRootInstanceLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  getZippedFile(
    path: string,
    vcsRootInstanceLocator: string,
    basePath?: string,
    locator?: string,
    name?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Check for the pending changes for all VCS root instances.
   * @param {string} [locator]
   * @param {string} [requestor]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  requestPendingChangesCheck(
    locator?: string,
    requestor?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<VcsRootInstances>;

  /**
   *
   * @summary Get a field of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} field
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  setVcsRootInstanceField(
    vcsRootInstanceLocator: string,
    field: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Update the repository state of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {Entries} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  setVcsRootInstanceRepositoryState(
    vcsRootInstanceLocator: string,
    fields?: string,
    body?: Entries,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Entries>;

  /**
   *
   * @summary Send the commit hook notification.
   * @param {string} [locator]
   * @param {boolean} [okOnNothingFound]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApiInterface
   */
  triggerCommitHookNotification(
    locator?: string,
    okOnNothingFound?: boolean,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;
}

/**
 * VcsRootInstanceApi - object-oriented interface
 * @export
 * @class VcsRootInstanceApi
 * @extends {BaseAPI}
 */
export class VcsRootInstanceApi extends BaseAPI implements VcsRootInstanceApiInterface {
  /**
   *
   * @summary Remove a field of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} field
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public deleteVcsRootInstanceField(
    vcsRootInstanceLocator: string,
    field: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .deleteVcsRootInstanceField(vcsRootInstanceLocator, field, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete the last repository state of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public deleteVcsRootInstanceRepositoryState(
    vcsRootInstanceLocator: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .deleteVcsRootInstanceRepositoryState(vcsRootInstanceLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download specific file.
   * @param {string} path
   * @param {string} vcsRootInstanceLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public downloadFile(
    path: string,
    vcsRootInstanceLocator: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .downloadFile(path, vcsRootInstanceLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all VCS root instances.
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getAllVcsRootInstances(
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getAllVcsRootInstances(locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get metadata of specific file.
   * @param {string} path
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getFileMetadata(
    path: string,
    vcsRootInstanceLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getFileMetadata(path, vcsRootInstanceLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all files.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getFilesList(
    vcsRootInstanceLocator: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getFilesList(vcsRootInstanceLocator, basePath, locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List files under this path.
   * @param {string} path
   * @param {string} vcsRootInstanceLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getFilesListForSubpath(
    path: string,
    vcsRootInstanceLocator: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getFilesListForSubpath(path, vcsRootInstanceLocator, basePath, locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get VCS root instance matching the locator.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getVcsRootInstance(
    vcsRootInstanceLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getVcsRootInstance(vcsRootInstanceLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the creation date of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getVcsRootInstanceCreationDate(
    vcsRootInstanceLocator: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getVcsRootInstanceCreationDate(vcsRootInstanceLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a field of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} field
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getVcsRootInstanceField(
    vcsRootInstanceLocator: string,
    field: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getVcsRootInstanceField(vcsRootInstanceLocator, field, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all properties of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getVcsRootInstanceProperties(
    vcsRootInstanceLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getVcsRootInstanceProperties(vcsRootInstanceLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the repository state of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getVcsRootInstanceRepositoryState(
    vcsRootInstanceLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getVcsRootInstanceRepositoryState(vcsRootInstanceLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get specific file zipped.
   * @param {string} path
   * @param {string} vcsRootInstanceLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public getZippedFile(
    path: string,
    vcsRootInstanceLocator: string,
    basePath?: string,
    locator?: string,
    name?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .getZippedFile(path, vcsRootInstanceLocator, basePath, locator, name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Check for the pending changes for all VCS root instances.
   * @param {string} [locator]
   * @param {string} [requestor]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public requestPendingChangesCheck(
    locator?: string,
    requestor?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .requestPendingChangesCheck(locator, requestor, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a field of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} field
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public setVcsRootInstanceField(
    vcsRootInstanceLocator: string,
    field: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .setVcsRootInstanceField(vcsRootInstanceLocator, field, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the repository state of the matching VCS root instance.
   * @param {string} vcsRootInstanceLocator
   * @param {string} [fields]
   * @param {Entries} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public setVcsRootInstanceRepositoryState(
    vcsRootInstanceLocator: string,
    fields?: string,
    body?: Entries,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .setVcsRootInstanceRepositoryState(vcsRootInstanceLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Send the commit hook notification.
   * @param {string} [locator]
   * @param {boolean} [okOnNothingFound]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof VcsRootInstanceApi
   */
  public triggerCommitHookNotification(
    locator?: string,
    okOnNothingFound?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return VcsRootInstanceApiFp(this.configuration)
      .triggerCommitHookNotification(locator, okOnNothingFound, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
