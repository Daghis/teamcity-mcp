/* tslint:disable */
/* eslint-disable */
/**
 * TeamCity REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2018.1 (current)
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  type RequestArgs,
  RequiredError,
  operationServerMap,
} from '../base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from '../common';
import type { Configuration } from '../configuration';
// @ts-ignore
import type { Build } from '../models';
// @ts-ignore
import type { BuildCancelRequest } from '../models';
// @ts-ignore
import type { BuildChanges } from '../models';
// @ts-ignore
import type { BuildStatusUpdate } from '../models';
// @ts-ignore
import type { Builds } from '../models';
// @ts-ignore
import type { Comment } from '../models';
// @ts-ignore
import type { Files } from '../models';
// @ts-ignore
import type { IssuesUsages } from '../models';
// @ts-ignore
import type { MultipleOperationResult } from '../models';
// @ts-ignore
import type { PinInfo } from '../models';
// @ts-ignore
import type { ProblemOccurrence } from '../models';
// @ts-ignore
import type { ProblemOccurrences } from '../models';
// @ts-ignore
import type { Properties } from '../models';
// @ts-ignore
import type { Tags } from '../models';
// @ts-ignore
import type { TestOccurrences } from '../models';
// @ts-ignore
import type { VcsLabels } from '../models';

/**
 * BuildApi - axios parameter creator
 * @export
 */
export const BuildApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add a VCS label to the matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addBuildVcsLabel: async (
      buildLocator: string,
      locator?: string,
      fields?: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('addBuildVcsLabel', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/vcsLabels`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Adds a message to the build log. Service messages are accepted.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLogMessageToBuild: async (
      buildLocator: string,
      fields?: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('addLogMessageToBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/log`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add a build problem to the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addProblemToBuild: async (
      buildLocator: string,
      fields?: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('addProblemToBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/problemOccurrences`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add tags to the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagsToBuild: async (
      buildLocator: string,
      fields?: string,
      body?: Tags,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('addTagsToBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/tags`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add tags to multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagsToMultipleBuilds: async (
      buildLocator: string,
      fields?: string,
      body?: Tags,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('addTagsToMultipleBuilds', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/multiple/{buildLocator}/tags`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary cancelBuild
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {BuildCancelRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBuild: async (
      buildLocator: string,
      fields?: string,
      body?: BuildCancelRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('cancelBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary cancelMultipleBuilds
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {BuildCancelRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelMultiple: async (
      buildLocator: string,
      fields?: string,
      body?: BuildCancelRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('cancelMultiple', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/multiple/{buildLocator}`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete build matching the locator.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBuild: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('deleteBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove the build comment matching the locator.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBuildComment: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('deleteBuildComment', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/comment`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete comments of multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMultipleBuildComments: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('deleteMultipleBuildComments', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/multiple/{buildLocator}/comment`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete multiple builds matching the locator.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMultipleBuilds: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('deleteMultipleBuilds', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/multiple/{buildLocator}`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Download specific file.
     * @param {string} path
     * @param {string} buildLocator
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFileOfBuild: async (
      path: string,
      buildLocator: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('downloadFileOfBuild', 'path', path);
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('downloadFileOfBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/artifacts/files{path}`
        .replace(`{${'path'}}`, encodeURIComponent(String(path)))
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (resolveParameters !== undefined) {
        localVarQueryParameter['resolveParameters'] = String(resolveParameters);
      }

      if (logBuildUsage !== undefined) {
        localVarQueryParameter['logBuildUsage'] = String(logBuildUsage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the build status of aggregated matching builds.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAggregatedBuildStatus: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getAggregatedBuildStatus', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/aggregated/{buildLocator}/status`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the status icon (in specified format) of aggregated matching builds.
     * @param {string} buildLocator
     * @param {string} suffix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAggregatedBuildStatusIcon: async (
      buildLocator: string,
      suffix: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getAggregatedBuildStatusIcon', 'buildLocator', buildLocator);
      // verify required parameter 'suffix' is not null or undefined
      assertParamExists('getAggregatedBuildStatusIcon', 'suffix', suffix);
      const localVarPath = `/app/rest/builds/aggregated/{buildLocator}/statusIcon{suffix}`
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)))
        .replace(`{${'suffix'}}`, encodeURIComponent(String(suffix)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all builds.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBuilds: async (
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/builds`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get artifact dependency changes of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArtifactDependencyChanges: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getArtifactDependencyChanges', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/artifactDependencyChanges`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the artifacts\' directory of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArtifactsDirectory: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getArtifactsDirectory', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/artifactsDirectory`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get build matching the locator.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuild: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get actual build parameters of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildActualParameters: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildActualParameters', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/resulting-properties`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a field of the matching build.
     * @param {string} buildLocator
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildField: async (
      buildLocator: string,
      field: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildField', 'buildLocator', buildLocator);
      // verify required parameter 'field' is not null or undefined
      assertParamExists('getBuildField', 'field', field);
      const localVarPath = `/app/rest/builds/{buildLocator}/{field}`
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)))
        .replace(`{${'field'}}`, encodeURIComponent(String(field)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the finish date of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildFinishDate: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildFinishDate', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/finishDate`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the number of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildNumber: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildNumber', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/number`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the value of a build output parameter.
     * @param {string} buildLocator
     * @param {string} propertyName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildOutputParameters: async (
      buildLocator: string,
      propertyName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildOutputParameters', 'buildLocator', buildLocator);
      // verify required parameter 'propertyName' is not null or undefined
      assertParamExists('getBuildOutputParameters', 'propertyName', propertyName);
      const localVarPath = `/app/rest/builds/{buildLocator}/output-parameters/{propertyName}`
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)))
        .replace(`{${'propertyName'}}`, encodeURIComponent(String(propertyName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get output parameters published by the build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildOutputParametersOfBuild: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildOutputParametersOfBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/output-parameters`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check if the matching build is pinned.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildPinInfo: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildPinInfo', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/pinInfo`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get build problems of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildProblems: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildProblems', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/problemOccurrences`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get related issues of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildRelatedIssues: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildRelatedIssues', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/relatedIssues`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the resolvement status of the matching build.
     * @param {string} buildLocator
     * @param {string} value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildResolved: async (
      buildLocator: string,
      value: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildResolved', 'buildLocator', buildLocator);
      // verify required parameter 'value' is not null or undefined
      assertParamExists('getBuildResolved', 'value', value);
      const localVarPath = `/app/rest/builds/{buildLocator}/resolved/{value}`
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)))
        .replace(`{${'value'}}`, encodeURIComponent(String(value)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the final value that a given parameter had after the build finished.
     * @param {string} buildLocator
     * @param {string} propertyName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildResultingProperties: async (
      buildLocator: string,
      propertyName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildResultingProperties', 'buildLocator', buildLocator);
      // verify required parameter 'propertyName' is not null or undefined
      assertParamExists('getBuildResultingProperties', 'propertyName', propertyName);
      const localVarPath = `/app/rest/builds/{buildLocator}/resulting-properties/{propertyName}`
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)))
        .replace(`{${'propertyName'}}`, encodeURIComponent(String(propertyName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a source file of the matching build.
     * @param {string} buildLocator
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildSourceFile: async (
      buildLocator: string,
      fileName: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildSourceFile', 'buildLocator', buildLocator);
      // verify required parameter 'fileName' is not null or undefined
      assertParamExists('getBuildSourceFile', 'fileName', fileName);
      const localVarPath = `/app/rest/builds/{buildLocator}/sources/files/{fileName}`
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)))
        .replace(`{${'fileName'}}`, encodeURIComponent(String(fileName)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a statistical value of the matching build.
     * @param {string} buildLocator
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatisticValue: async (
      buildLocator: string,
      name: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildStatisticValue', 'buildLocator', buildLocator);
      // verify required parameter 'name' is not null or undefined
      assertParamExists('getBuildStatisticValue', 'name', name);
      const localVarPath = `/app/rest/builds/{buildLocator}/statistics/{name}`
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)))
        .replace(`{${'name'}}`, encodeURIComponent(String(name)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all statistical values of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatisticValues: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildStatisticValues', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/statistics`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get status of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatus: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildStatus', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/status`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the status icon (in specified format) of the matching build.
     * @param {string} buildLocator
     * @param {string} suffix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatusIcon: async (
      buildLocator: string,
      suffix: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildStatusIcon', 'buildLocator', buildLocator);
      // verify required parameter 'suffix' is not null or undefined
      assertParamExists('getBuildStatusIcon', 'suffix', suffix);
      const localVarPath = `/app/rest/builds/{buildLocator}/statusIcon{suffix}`
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)))
        .replace(`{${'suffix'}}`, encodeURIComponent(String(suffix)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the build status text of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatusText: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildStatusText', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/statusText`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get tags of the matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildTags: async (
      buildLocator: string,
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildTags', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/tags`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get test occurrences of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildTestOccurrences: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildTestOccurrences', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/testOccurrences`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get VCS labels of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildVcsLabels: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getBuildVcsLabels', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/vcsLabels`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Check if the matching build is canceled.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCanceledInfo: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getCanceledInfo', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/canceledInfo`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get metadata of specific file.
     * @param {string} path
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadataOfBuild: async (
      path: string,
      buildLocator: string,
      fields?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getFileMetadataOfBuild', 'path', path);
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getFileMetadataOfBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/artifacts/metadata{path}`
        .replace(`{${'path'}}`, encodeURIComponent(String(path)))
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      if (resolveParameters !== undefined) {
        localVarQueryParameter['resolveParameters'] = String(resolveParameters);
      }

      if (logBuildUsage !== undefined) {
        localVarQueryParameter['logBuildUsage'] = String(logBuildUsage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List files under this path.
     * @param {string} path
     * @param {string} buildLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListForSubpathOfBuild: async (
      path: string,
      buildLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getFilesListForSubpathOfBuild', 'path', path);
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getFilesListForSubpathOfBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/artifacts/{path}`
        .replace(`{${'path'}}`, encodeURIComponent(String(path)))
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (basePath !== undefined) {
        localVarQueryParameter['basePath'] = String(basePath);
      }

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      if (resolveParameters !== undefined) {
        localVarQueryParameter['resolveParameters'] = String(resolveParameters);
      }

      if (logBuildUsage !== undefined) {
        localVarQueryParameter['logBuildUsage'] = String(logBuildUsage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary List all files.
     * @param {string} buildLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListOfBuild: async (
      buildLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getFilesListOfBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/artifacts`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (basePath !== undefined) {
        localVarQueryParameter['basePath'] = String(basePath);
      }

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      if (resolveParameters !== undefined) {
        localVarQueryParameter['resolveParameters'] = String(resolveParameters);
      }

      if (logBuildUsage !== undefined) {
        localVarQueryParameter['logBuildUsage'] = String(logBuildUsage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get multiple builds matching the locator.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleBuilds: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getMultipleBuilds', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/multiple/{buildLocator}`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get specific file zipped.
     * @param {string} path
     * @param {string} buildLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [name]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getZippedFileOfBuild: async (
      path: string,
      buildLocator: string,
      basePath?: string,
      locator?: string,
      name?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'path' is not null or undefined
      assertParamExists('getZippedFileOfBuild', 'path', path);
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getZippedFileOfBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/artifacts/archived{path}`
        .replace(`{${'path'}}`, encodeURIComponent(String(path)))
        .replace(`{${'buildLocator'}}`, encodeURIComponent(String(buildLocator)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (basePath !== undefined) {
        localVarQueryParameter['basePath'] = String(basePath);
      }

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = String(name);
      }

      if (resolveParameters !== undefined) {
        localVarQueryParameter['resolveParameters'] = String(resolveParameters);
      }

      if (logBuildUsage !== undefined) {
        localVarQueryParameter['logBuildUsage'] = String(logBuildUsage);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Starts the queued build as an agent-less build and returns the corresponding running build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markBuildAsRunning: async (
      buildLocator: string,
      fields?: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('markBuildAsRunning', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/runningData`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Pin multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {PinInfo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinMultipleBuilds: async (
      buildLocator: string,
      fields?: string,
      body?: PinInfo,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('pinMultipleBuilds', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/multiple/{buildLocator}/pinInfo`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove tags from multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMultipleBuildTags: async (
      buildLocator: string,
      fields?: string,
      body?: Tags,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('removeMultipleBuildTags', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/multiple/{buildLocator}/tags`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove build parameters from the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetBuildFinishProperties: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('resetBuildFinishProperties', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/caches/finishProperties`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the comment on the matching build.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildComment: async (
      buildLocator: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('setBuildComment', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/comment`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Marks the running build as finished by passing agent the current time of the build to finish.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildFinishDate: async (
      buildLocator: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('setBuildFinishDate', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/finishDate`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the number of the matching build.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildNumber: async (
      buildLocator: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('setBuildNumber', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/number`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the pin info of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {PinInfo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildPinInfo: async (
      buildLocator: string,
      fields?: string,
      body?: PinInfo,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('setBuildPinInfo', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/pinInfo`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Change status of the build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {BuildStatusUpdate} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildStatus: async (
      buildLocator: string,
      fields?: string,
      body?: BuildStatusUpdate,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('setBuildStatus', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/status`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the build status of the matching build.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildStatusText: async (
      buildLocator: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('setBuildStatusText', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/statusText`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update tags of the matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildTags: async (
      buildLocator: string,
      locator?: string,
      fields?: string,
      body?: Tags,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('setBuildTags', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/tags`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Marks the running build as finished by passing agent the current time of the build to finish.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFinishedTime: async (
      buildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('setFinishedTime', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/{buildLocator}/finish`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update comments in multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMultipleBuildComments: async (
      buildLocator: string,
      fields?: string,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('setMultipleBuildComments', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/builds/multiple/{buildLocator}/comment`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'text/plain';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BuildApi - functional programming interface
 * @export
 */
export const BuildApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BuildApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Add a VCS label to the matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addBuildVcsLabel(
      buildLocator: string,
      locator?: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VcsLabels>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addBuildVcsLabel(
        buildLocator,
        locator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.addBuildVcsLabel']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Adds a message to the build log. Service messages are accepted.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addLogMessageToBuild(
      buildLocator: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addLogMessageToBuild(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.addLogMessageToBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Add a build problem to the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addProblemToBuild(
      buildLocator: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemOccurrence>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addProblemToBuild(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.addProblemToBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Add tags to the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTagsToBuild(
      buildLocator: string,
      fields?: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addTagsToBuild(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.addTagsToBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Add tags to multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTagsToMultipleBuilds(
      buildLocator: string,
      fields?: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultipleOperationResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addTagsToMultipleBuilds(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.addTagsToMultipleBuilds']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary cancelBuild
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {BuildCancelRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelBuild(
      buildLocator: string,
      fields?: string,
      body?: BuildCancelRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelBuild(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.cancelBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary cancelMultipleBuilds
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {BuildCancelRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelMultiple(
      buildLocator: string,
      fields?: string,
      body?: BuildCancelRequest,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultipleOperationResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelMultiple(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.cancelMultiple']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete build matching the locator.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteBuild(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuild(buildLocator, options);
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.deleteBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Remove the build comment matching the locator.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteBuildComment(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuildComment(
        buildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.deleteBuildComment']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete comments of multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMultipleBuildComments(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultipleOperationResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMultipleBuildComments(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.deleteMultipleBuildComments']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete multiple builds matching the locator.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteMultipleBuilds(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultipleOperationResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMultipleBuilds(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.deleteMultipleBuilds']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Download specific file.
     * @param {string} path
     * @param {string} buildLocator
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadFileOfBuild(
      path: string,
      buildLocator: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.downloadFileOfBuild(
        path,
        buildLocator,
        resolveParameters,
        logBuildUsage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.downloadFileOfBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the build status of aggregated matching builds.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAggregatedBuildStatus(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedBuildStatus(
        buildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getAggregatedBuildStatus']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the status icon (in specified format) of aggregated matching builds.
     * @param {string} buildLocator
     * @param {string} suffix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAggregatedBuildStatusIcon(
      buildLocator: string,
      suffix: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedBuildStatusIcon(
        buildLocator,
        suffix,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getAggregatedBuildStatusIcon']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all builds.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllBuilds(
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Builds>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllBuilds(
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getAllBuilds']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get artifact dependency changes of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getArtifactDependencyChanges(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BuildChanges>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactDependencyChanges(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getArtifactDependencyChanges']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the artifacts\' directory of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getArtifactsDirectory(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactsDirectory(
        buildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getArtifactsDirectory']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get build matching the locator.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuild(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuild(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get actual build parameters of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildActualParameters(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Properties>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildActualParameters(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildActualParameters']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a field of the matching build.
     * @param {string} buildLocator
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildField(
      buildLocator: string,
      field: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildField(
        buildLocator,
        field,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildField']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the finish date of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildFinishDate(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildFinishDate(
        buildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildFinishDate']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the number of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildNumber(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildNumber(
        buildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildNumber']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Returns the value of a build output parameter.
     * @param {string} buildLocator
     * @param {string} propertyName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildOutputParameters(
      buildLocator: string,
      propertyName: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildOutputParameters(
        buildLocator,
        propertyName,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildOutputParameters']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get output parameters published by the build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildOutputParametersOfBuild(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Properties>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildOutputParametersOfBuild(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildOutputParametersOfBuild']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Check if the matching build is pinned.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildPinInfo(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildPinInfo(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildPinInfo']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get build problems of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildProblems(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProblemOccurrences>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildProblems(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildProblems']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get related issues of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildRelatedIssues(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssuesUsages>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildRelatedIssues(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildRelatedIssues']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the resolvement status of the matching build.
     * @param {string} buildLocator
     * @param {string} value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildResolved(
      buildLocator: string,
      value: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildResolved(
        buildLocator,
        value,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildResolved']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Returns the final value that a given parameter had after the build finished.
     * @param {string} buildLocator
     * @param {string} propertyName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildResultingProperties(
      buildLocator: string,
      propertyName: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildResultingProperties(
        buildLocator,
        propertyName,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildResultingProperties']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a source file of the matching build.
     * @param {string} buildLocator
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildSourceFile(
      buildLocator: string,
      fileName: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildSourceFile(
        buildLocator,
        fileName,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildSourceFile']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a statistical value of the matching build.
     * @param {string} buildLocator
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildStatisticValue(
      buildLocator: string,
      name: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildStatisticValue(
        buildLocator,
        name,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildStatisticValue']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all statistical values of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildStatisticValues(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Properties>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildStatisticValues(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildStatisticValues']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get status of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildStatus(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildStatus(
        buildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildStatus']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the status icon (in specified format) of the matching build.
     * @param {string} buildLocator
     * @param {string} suffix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildStatusIcon(
      buildLocator: string,
      suffix: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildStatusIcon(
        buildLocator,
        suffix,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildStatusIcon']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the build status text of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildStatusText(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildStatusText(
        buildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildStatusText']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get tags of the matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildTags(
      buildLocator: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildTags(
        buildLocator,
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildTags']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get test occurrences of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildTestOccurrences(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestOccurrences>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildTestOccurrences(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildTestOccurrences']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get VCS labels of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBuildVcsLabels(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VcsLabels>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBuildVcsLabels(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getBuildVcsLabels']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Check if the matching build is canceled.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCanceledInfo(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCanceledInfo(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getCanceledInfo']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get metadata of specific file.
     * @param {string} path
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileMetadataOfBuild(
      path: string,
      buildLocator: string,
      fields?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileMetadataOfBuild(
        path,
        buildLocator,
        fields,
        resolveParameters,
        logBuildUsage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getFileMetadataOfBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List files under this path.
     * @param {string} path
     * @param {string} buildLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilesListForSubpathOfBuild(
      path: string,
      buildLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Files>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesListForSubpathOfBuild(
        path,
        buildLocator,
        basePath,
        locator,
        fields,
        resolveParameters,
        logBuildUsage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getFilesListForSubpathOfBuild']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary List all files.
     * @param {string} buildLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFilesListOfBuild(
      buildLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Files>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFilesListOfBuild(
        buildLocator,
        basePath,
        locator,
        fields,
        resolveParameters,
        logBuildUsage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getFilesListOfBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get multiple builds matching the locator.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getMultipleBuilds(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Builds>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getMultipleBuilds(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getMultipleBuilds']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get specific file zipped.
     * @param {string} path
     * @param {string} buildLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [name]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getZippedFileOfBuild(
      path: string,
      buildLocator: string,
      basePath?: string,
      locator?: string,
      name?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getZippedFileOfBuild(
        path,
        buildLocator,
        basePath,
        locator,
        name,
        resolveParameters,
        logBuildUsage,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.getZippedFileOfBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Starts the queued build as an agent-less build and returns the corresponding running build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async markBuildAsRunning(
      buildLocator: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.markBuildAsRunning(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.markBuildAsRunning']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Pin multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {PinInfo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async pinMultipleBuilds(
      buildLocator: string,
      fields?: string,
      body?: PinInfo,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultipleOperationResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.pinMultipleBuilds(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.pinMultipleBuilds']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Remove tags from multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeMultipleBuildTags(
      buildLocator: string,
      fields?: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultipleOperationResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removeMultipleBuildTags(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.removeMultipleBuildTags']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Remove build parameters from the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async resetBuildFinishProperties(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.resetBuildFinishProperties(
        buildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.resetBuildFinishProperties']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update the comment on the matching build.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setBuildComment(
      buildLocator: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setBuildComment(
        buildLocator,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.setBuildComment']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Marks the running build as finished by passing agent the current time of the build to finish.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setBuildFinishDate(
      buildLocator: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setBuildFinishDate(
        buildLocator,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.setBuildFinishDate']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update the number of the matching build.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setBuildNumber(
      buildLocator: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setBuildNumber(
        buildLocator,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.setBuildNumber']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update the pin info of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {PinInfo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setBuildPinInfo(
      buildLocator: string,
      fields?: string,
      body?: PinInfo,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setBuildPinInfo(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.setBuildPinInfo']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Change status of the build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {BuildStatusUpdate} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setBuildStatus(
      buildLocator: string,
      fields?: string,
      body?: BuildStatusUpdate,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setBuildStatus(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.setBuildStatus']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update the build status of the matching build.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setBuildStatusText(
      buildLocator: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setBuildStatusText(
        buildLocator,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.setBuildStatusText']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update tags of the matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setBuildTags(
      buildLocator: string,
      locator?: string,
      fields?: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setBuildTags(
        buildLocator,
        locator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.setBuildTags']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Marks the running build as finished by passing agent the current time of the build to finish.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setFinishedTime(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setFinishedTime(
        buildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.setFinishedTime']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update comments in multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setMultipleBuildComments(
      buildLocator: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultipleOperationResult>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setMultipleBuildComments(
        buildLocator,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildApi.setMultipleBuildComments']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BuildApi - factory interface
 * @export
 */
export const BuildApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BuildApiFp(configuration);
  return {
    /**
     *
     * @summary Add a VCS label to the matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addBuildVcsLabel(
      buildLocator: string,
      locator?: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VcsLabels> {
      return localVarFp
        .addBuildVcsLabel(buildLocator, locator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Adds a message to the build log. Service messages are accepted.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addLogMessageToBuild(
      buildLocator: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .addLogMessageToBuild(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add a build problem to the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addProblemToBuild(
      buildLocator: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ProblemOccurrence> {
      return localVarFp
        .addProblemToBuild(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add tags to the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagsToBuild(
      buildLocator: string,
      fields?: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Tags> {
      return localVarFp
        .addTagsToBuild(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add tags to multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagsToMultipleBuilds(
      buildLocator: string,
      fields?: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MultipleOperationResult> {
      return localVarFp
        .addTagsToMultipleBuilds(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary cancelBuild
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {BuildCancelRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelBuild(
      buildLocator: string,
      fields?: string,
      body?: BuildCancelRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Build> {
      return localVarFp
        .cancelBuild(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary cancelMultipleBuilds
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {BuildCancelRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelMultiple(
      buildLocator: string,
      fields?: string,
      body?: BuildCancelRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MultipleOperationResult> {
      return localVarFp
        .cancelMultiple(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete build matching the locator.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBuild(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .deleteBuild(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove the build comment matching the locator.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBuildComment(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
      return localVarFp
        .deleteBuildComment(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete comments of multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMultipleBuildComments(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MultipleOperationResult> {
      return localVarFp
        .deleteMultipleBuildComments(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete multiple builds matching the locator.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMultipleBuilds(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MultipleOperationResult> {
      return localVarFp
        .deleteMultipleBuilds(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Download specific file.
     * @param {string} path
     * @param {string} buildLocator
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadFileOfBuild(
      path: string,
      buildLocator: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .downloadFileOfBuild(path, buildLocator, resolveParameters, logBuildUsage, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the build status of aggregated matching builds.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAggregatedBuildStatus(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getAggregatedBuildStatus(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the status icon (in specified format) of aggregated matching builds.
     * @param {string} buildLocator
     * @param {string} suffix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAggregatedBuildStatusIcon(
      buildLocator: string,
      suffix: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .getAggregatedBuildStatusIcon(buildLocator, suffix, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all builds.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBuilds(
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Builds> {
      return localVarFp
        .getAllBuilds(locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get artifact dependency changes of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArtifactDependencyChanges(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<BuildChanges> {
      return localVarFp
        .getArtifactDependencyChanges(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the artifacts\' directory of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getArtifactsDirectory(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getArtifactsDirectory(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get build matching the locator.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuild(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Build> {
      return localVarFp
        .getBuild(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get actual build parameters of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildActualParameters(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Properties> {
      return localVarFp
        .getBuildActualParameters(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a field of the matching build.
     * @param {string} buildLocator
     * @param {string} field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildField(
      buildLocator: string,
      field: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getBuildField(buildLocator, field, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the finish date of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildFinishDate(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getBuildFinishDate(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the number of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildNumber(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .getBuildNumber(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the value of a build output parameter.
     * @param {string} buildLocator
     * @param {string} propertyName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildOutputParameters(
      buildLocator: string,
      propertyName: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getBuildOutputParameters(buildLocator, propertyName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get output parameters published by the build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildOutputParametersOfBuild(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Properties> {
      return localVarFp
        .getBuildOutputParametersOfBuild(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Check if the matching build is pinned.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildPinInfo(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PinInfo> {
      return localVarFp
        .getBuildPinInfo(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get build problems of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildProblems(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ProblemOccurrences> {
      return localVarFp
        .getBuildProblems(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get related issues of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildRelatedIssues(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<IssuesUsages> {
      return localVarFp
        .getBuildRelatedIssues(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the resolvement status of the matching build.
     * @param {string} buildLocator
     * @param {string} value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildResolved(
      buildLocator: string,
      value: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getBuildResolved(buildLocator, value, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the final value that a given parameter had after the build finished.
     * @param {string} buildLocator
     * @param {string} propertyName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildResultingProperties(
      buildLocator: string,
      propertyName: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getBuildResultingProperties(buildLocator, propertyName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a source file of the matching build.
     * @param {string} buildLocator
     * @param {string} fileName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildSourceFile(
      buildLocator: string,
      fileName: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .getBuildSourceFile(buildLocator, fileName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a statistical value of the matching build.
     * @param {string} buildLocator
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatisticValue(
      buildLocator: string,
      name: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getBuildStatisticValue(buildLocator, name, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all statistical values of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatisticValues(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Properties> {
      return localVarFp
        .getBuildStatisticValues(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get status of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatus(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .getBuildStatus(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the status icon (in specified format) of the matching build.
     * @param {string} buildLocator
     * @param {string} suffix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatusIcon(
      buildLocator: string,
      suffix: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .getBuildStatusIcon(buildLocator, suffix, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the build status text of the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildStatusText(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .getBuildStatusText(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get tags of the matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildTags(
      buildLocator: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Tags> {
      return localVarFp
        .getBuildTags(buildLocator, locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get test occurrences of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildTestOccurrences(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<TestOccurrences> {
      return localVarFp
        .getBuildTestOccurrences(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get VCS labels of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBuildVcsLabels(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<VcsLabels> {
      return localVarFp
        .getBuildVcsLabels(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Check if the matching build is canceled.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCanceledInfo(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Comment> {
      return localVarFp
        .getCanceledInfo(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get metadata of specific file.
     * @param {string} path
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadataOfBuild(
      path: string,
      buildLocator: string,
      fields?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<any> {
      return localVarFp
        .getFileMetadataOfBuild(
          path,
          buildLocator,
          fields,
          resolveParameters,
          logBuildUsage,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List files under this path.
     * @param {string} path
     * @param {string} buildLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListForSubpathOfBuild(
      path: string,
      buildLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Files> {
      return localVarFp
        .getFilesListForSubpathOfBuild(
          path,
          buildLocator,
          basePath,
          locator,
          fields,
          resolveParameters,
          logBuildUsage,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary List all files.
     * @param {string} buildLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFilesListOfBuild(
      buildLocator: string,
      basePath?: string,
      locator?: string,
      fields?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Files> {
      return localVarFp
        .getFilesListOfBuild(
          buildLocator,
          basePath,
          locator,
          fields,
          resolveParameters,
          logBuildUsage,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get multiple builds matching the locator.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMultipleBuilds(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Builds> {
      return localVarFp
        .getMultipleBuilds(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get specific file zipped.
     * @param {string} path
     * @param {string} buildLocator
     * @param {string} [basePath]
     * @param {string} [locator]
     * @param {string} [name]
     * @param {boolean} [resolveParameters]
     * @param {boolean} [logBuildUsage]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getZippedFileOfBuild(
      path: string,
      buildLocator: string,
      basePath?: string,
      locator?: string,
      name?: string,
      resolveParameters?: boolean,
      logBuildUsage?: boolean,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .getZippedFileOfBuild(
          path,
          buildLocator,
          basePath,
          locator,
          name,
          resolveParameters,
          logBuildUsage,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Starts the queued build as an agent-less build and returns the corresponding running build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    markBuildAsRunning(
      buildLocator: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Build> {
      return localVarFp
        .markBuildAsRunning(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Pin multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {PinInfo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pinMultipleBuilds(
      buildLocator: string,
      fields?: string,
      body?: PinInfo,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MultipleOperationResult> {
      return localVarFp
        .pinMultipleBuilds(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove tags from multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeMultipleBuildTags(
      buildLocator: string,
      fields?: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MultipleOperationResult> {
      return localVarFp
        .removeMultipleBuildTags(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove build parameters from the matching build.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resetBuildFinishProperties(
      buildLocator: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .resetBuildFinishProperties(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the comment on the matching build.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildComment(
      buildLocator: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .setBuildComment(buildLocator, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Marks the running build as finished by passing agent the current time of the build to finish.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildFinishDate(
      buildLocator: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .setBuildFinishDate(buildLocator, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the number of the matching build.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildNumber(
      buildLocator: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .setBuildNumber(buildLocator, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the pin info of the matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {PinInfo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildPinInfo(
      buildLocator: string,
      fields?: string,
      body?: PinInfo,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<PinInfo> {
      return localVarFp
        .setBuildPinInfo(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Change status of the build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {BuildStatusUpdate} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildStatus(
      buildLocator: string,
      fields?: string,
      body?: BuildStatusUpdate,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .setBuildStatus(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the build status of the matching build.
     * @param {string} buildLocator
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildStatusText(
      buildLocator: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<string> {
      return localVarFp
        .setBuildStatusText(buildLocator, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update tags of the matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setBuildTags(
      buildLocator: string,
      locator?: string,
      fields?: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Tags> {
      return localVarFp
        .setBuildTags(buildLocator, locator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Marks the running build as finished by passing agent the current time of the build to finish.
     * @param {string} buildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setFinishedTime(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
      return localVarFp
        .setFinishedTime(buildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update comments in multiple matching builds.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setMultipleBuildComments(
      buildLocator: string,
      fields?: string,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<MultipleOperationResult> {
      return localVarFp
        .setMultipleBuildComments(buildLocator, fields, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BuildApi - interface
 * @export
 * @interface BuildApi
 */
export interface BuildApiInterface {
  /**
   *
   * @summary Add a VCS label to the matching build.
   * @param {string} buildLocator
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  addBuildVcsLabel(
    buildLocator: string,
    locator?: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<VcsLabels>;

  /**
   *
   * @summary Adds a message to the build log. Service messages are accepted.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  addLogMessageToBuild(
    buildLocator: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Add a build problem to the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  addProblemToBuild(
    buildLocator: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ProblemOccurrence>;

  /**
   *
   * @summary Add tags to the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  addTagsToBuild(
    buildLocator: string,
    fields?: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Tags>;

  /**
   *
   * @summary Add tags to multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  addTagsToMultipleBuilds(
    buildLocator: string,
    fields?: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<MultipleOperationResult>;

  /**
   *
   * @summary cancelBuild
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {BuildCancelRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  cancelBuild(
    buildLocator: string,
    fields?: string,
    body?: BuildCancelRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Build>;

  /**
   *
   * @summary cancelMultipleBuilds
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {BuildCancelRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  cancelMultiple(
    buildLocator: string,
    fields?: string,
    body?: BuildCancelRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<MultipleOperationResult>;

  /**
   *
   * @summary Delete build matching the locator.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  deleteBuild(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @summary Remove the build comment matching the locator.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  deleteBuildComment(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<void>;

  /**
   *
   * @summary Delete comments of multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  deleteMultipleBuildComments(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<MultipleOperationResult>;

  /**
   *
   * @summary Delete multiple builds matching the locator.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  deleteMultipleBuilds(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<MultipleOperationResult>;

  /**
   *
   * @summary Download specific file.
   * @param {string} path
   * @param {string} buildLocator
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  downloadFileOfBuild(
    path: string,
    buildLocator: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get the build status of aggregated matching builds.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getAggregatedBuildStatus(
    buildLocator: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Get the status icon (in specified format) of aggregated matching builds.
   * @param {string} buildLocator
   * @param {string} suffix
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getAggregatedBuildStatusIcon(
    buildLocator: string,
    suffix: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get all builds.
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getAllBuilds(
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Builds>;

  /**
   *
   * @summary Get artifact dependency changes of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getArtifactDependencyChanges(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<BuildChanges>;

  /**
   *
   * @summary Get the artifacts\' directory of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getArtifactsDirectory(
    buildLocator: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Get build matching the locator.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuild(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Build>;

  /**
   *
   * @summary Get actual build parameters of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildActualParameters(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Properties>;

  /**
   *
   * @summary Get a field of the matching build.
   * @param {string} buildLocator
   * @param {string} field
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildField(
    buildLocator: string,
    field: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Get the finish date of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildFinishDate(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @summary Get the number of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildNumber(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @summary Returns the value of a build output parameter.
   * @param {string} buildLocator
   * @param {string} propertyName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildOutputParameters(
    buildLocator: string,
    propertyName: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Get output parameters published by the build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildOutputParametersOfBuild(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Properties>;

  /**
   *
   * @summary Check if the matching build is pinned.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildPinInfo(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<PinInfo>;

  /**
   *
   * @summary Get build problems of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildProblems(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ProblemOccurrences>;

  /**
   *
   * @summary Get related issues of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildRelatedIssues(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<IssuesUsages>;

  /**
   *
   * @summary Get the resolvement status of the matching build.
   * @param {string} buildLocator
   * @param {string} value
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildResolved(
    buildLocator: string,
    value: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Returns the final value that a given parameter had after the build finished.
   * @param {string} buildLocator
   * @param {string} propertyName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildResultingProperties(
    buildLocator: string,
    propertyName: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Get a source file of the matching build.
   * @param {string} buildLocator
   * @param {string} fileName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildSourceFile(
    buildLocator: string,
    fileName: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get a statistical value of the matching build.
   * @param {string} buildLocator
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildStatisticValue(
    buildLocator: string,
    name: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Get all statistical values of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildStatisticValues(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Properties>;

  /**
   *
   * @summary Get status of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildStatus(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @summary Get the status icon (in specified format) of the matching build.
   * @param {string} buildLocator
   * @param {string} suffix
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildStatusIcon(
    buildLocator: string,
    suffix: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get the build status text of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildStatusText(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @summary Get tags of the matching build.
   * @param {string} buildLocator
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildTags(
    buildLocator: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Tags>;

  /**
   *
   * @summary Get test occurrences of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildTestOccurrences(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<TestOccurrences>;

  /**
   *
   * @summary Get VCS labels of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getBuildVcsLabels(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<VcsLabels>;

  /**
   *
   * @summary Check if the matching build is canceled.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getCanceledInfo(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Comment>;

  /**
   *
   * @summary Get metadata of specific file.
   * @param {string} path
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getFileMetadataOfBuild(
    path: string,
    buildLocator: string,
    fields?: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<any>;

  /**
   *
   * @summary List files under this path.
   * @param {string} path
   * @param {string} buildLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getFilesListForSubpathOfBuild(
    path: string,
    buildLocator: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Files>;

  /**
   *
   * @summary List all files.
   * @param {string} buildLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getFilesListOfBuild(
    buildLocator: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Files>;

  /**
   *
   * @summary Get multiple builds matching the locator.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getMultipleBuilds(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Builds>;

  /**
   *
   * @summary Get specific file zipped.
   * @param {string} path
   * @param {string} buildLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [name]
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  getZippedFileOfBuild(
    path: string,
    buildLocator: string,
    basePath?: string,
    locator?: string,
    name?: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Starts the queued build as an agent-less build and returns the corresponding running build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  markBuildAsRunning(
    buildLocator: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Build>;

  /**
   *
   * @summary Pin multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {PinInfo} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  pinMultipleBuilds(
    buildLocator: string,
    fields?: string,
    body?: PinInfo,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<MultipleOperationResult>;

  /**
   *
   * @summary Remove tags from multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  removeMultipleBuildTags(
    buildLocator: string,
    fields?: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<MultipleOperationResult>;

  /**
   *
   * @summary Remove build parameters from the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  resetBuildFinishProperties(
    buildLocator: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Update the comment on the matching build.
   * @param {string} buildLocator
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  setBuildComment(
    buildLocator: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Marks the running build as finished by passing agent the current time of the build to finish.
   * @param {string} buildLocator
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  setBuildFinishDate(
    buildLocator: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Update the number of the matching build.
   * @param {string} buildLocator
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  setBuildNumber(
    buildLocator: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Update the pin info of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {PinInfo} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  setBuildPinInfo(
    buildLocator: string,
    fields?: string,
    body?: PinInfo,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<PinInfo>;

  /**
   *
   * @summary Change status of the build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {BuildStatusUpdate} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  setBuildStatus(
    buildLocator: string,
    fields?: string,
    body?: BuildStatusUpdate,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Update the build status of the matching build.
   * @param {string} buildLocator
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  setBuildStatusText(
    buildLocator: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<string>;

  /**
   *
   * @summary Update tags of the matching build.
   * @param {string} buildLocator
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  setBuildTags(
    buildLocator: string,
    locator?: string,
    fields?: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Tags>;

  /**
   *
   * @summary Marks the running build as finished by passing agent the current time of the build to finish.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  setFinishedTime(buildLocator: string, options?: RawAxiosRequestConfig): AxiosPromise<string>;

  /**
   *
   * @summary Update comments in multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApiInterface
   */
  setMultipleBuildComments(
    buildLocator: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<MultipleOperationResult>;
}

/**
 * BuildApi - object-oriented interface
 * @export
 * @class BuildApi
 * @extends {BaseAPI}
 */
export class BuildApi extends BaseAPI implements BuildApiInterface {
  /**
   *
   * @summary Add a VCS label to the matching build.
   * @param {string} buildLocator
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public addBuildVcsLabel(
    buildLocator: string,
    locator?: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .addBuildVcsLabel(buildLocator, locator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Adds a message to the build log. Service messages are accepted.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public addLogMessageToBuild(
    buildLocator: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .addLogMessageToBuild(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add a build problem to the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public addProblemToBuild(
    buildLocator: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .addProblemToBuild(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add tags to the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public addTagsToBuild(
    buildLocator: string,
    fields?: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .addTagsToBuild(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add tags to multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public addTagsToMultipleBuilds(
    buildLocator: string,
    fields?: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .addTagsToMultipleBuilds(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary cancelBuild
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {BuildCancelRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public cancelBuild(
    buildLocator: string,
    fields?: string,
    body?: BuildCancelRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .cancelBuild(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary cancelMultipleBuilds
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {BuildCancelRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public cancelMultiple(
    buildLocator: string,
    fields?: string,
    body?: BuildCancelRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .cancelMultiple(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete build matching the locator.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public deleteBuild(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .deleteBuild(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove the build comment matching the locator.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public deleteBuildComment(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .deleteBuildComment(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete comments of multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public deleteMultipleBuildComments(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .deleteMultipleBuildComments(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete multiple builds matching the locator.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public deleteMultipleBuilds(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .deleteMultipleBuilds(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Download specific file.
   * @param {string} path
   * @param {string} buildLocator
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public downloadFileOfBuild(
    path: string,
    buildLocator: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .downloadFileOfBuild(path, buildLocator, resolveParameters, logBuildUsage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the build status of aggregated matching builds.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getAggregatedBuildStatus(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getAggregatedBuildStatus(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the status icon (in specified format) of aggregated matching builds.
   * @param {string} buildLocator
   * @param {string} suffix
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getAggregatedBuildStatusIcon(
    buildLocator: string,
    suffix: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getAggregatedBuildStatusIcon(buildLocator, suffix, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all builds.
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getAllBuilds(locator?: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getAllBuilds(locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get artifact dependency changes of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getArtifactDependencyChanges(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getArtifactDependencyChanges(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the artifacts\' directory of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getArtifactsDirectory(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getArtifactsDirectory(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get build matching the locator.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuild(buildLocator: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuild(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get actual build parameters of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildActualParameters(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildActualParameters(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a field of the matching build.
   * @param {string} buildLocator
   * @param {string} field
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildField(buildLocator: string, field: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildField(buildLocator, field, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the finish date of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildFinishDate(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildFinishDate(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the number of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildNumber(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildNumber(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns the value of a build output parameter.
   * @param {string} buildLocator
   * @param {string} propertyName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildOutputParameters(
    buildLocator: string,
    propertyName: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildOutputParameters(buildLocator, propertyName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get output parameters published by the build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildOutputParametersOfBuild(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildOutputParametersOfBuild(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Check if the matching build is pinned.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildPinInfo(buildLocator: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildPinInfo(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get build problems of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildProblems(buildLocator: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildProblems(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get related issues of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildRelatedIssues(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildRelatedIssues(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the resolvement status of the matching build.
   * @param {string} buildLocator
   * @param {string} value
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildResolved(buildLocator: string, value: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildResolved(buildLocator, value, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns the final value that a given parameter had after the build finished.
   * @param {string} buildLocator
   * @param {string} propertyName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildResultingProperties(
    buildLocator: string,
    propertyName: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildResultingProperties(buildLocator, propertyName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a source file of the matching build.
   * @param {string} buildLocator
   * @param {string} fileName
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildSourceFile(
    buildLocator: string,
    fileName: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildSourceFile(buildLocator, fileName, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a statistical value of the matching build.
   * @param {string} buildLocator
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildStatisticValue(
    buildLocator: string,
    name: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildStatisticValue(buildLocator, name, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all statistical values of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildStatisticValues(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildStatisticValues(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get status of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildStatus(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildStatus(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the status icon (in specified format) of the matching build.
   * @param {string} buildLocator
   * @param {string} suffix
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildStatusIcon(buildLocator: string, suffix: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildStatusIcon(buildLocator, suffix, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the build status text of the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildStatusText(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildStatusText(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get tags of the matching build.
   * @param {string} buildLocator
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildTags(
    buildLocator: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildTags(buildLocator, locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get test occurrences of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildTestOccurrences(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getBuildTestOccurrences(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get VCS labels of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getBuildVcsLabels(buildLocator: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getBuildVcsLabels(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Check if the matching build is canceled.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getCanceledInfo(buildLocator: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getCanceledInfo(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get metadata of specific file.
   * @param {string} path
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getFileMetadataOfBuild(
    path: string,
    buildLocator: string,
    fields?: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getFileMetadataOfBuild(path, buildLocator, fields, resolveParameters, logBuildUsage, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List files under this path.
   * @param {string} path
   * @param {string} buildLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getFilesListForSubpathOfBuild(
    path: string,
    buildLocator: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getFilesListForSubpathOfBuild(
        path,
        buildLocator,
        basePath,
        locator,
        fields,
        resolveParameters,
        logBuildUsage,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary List all files.
   * @param {string} buildLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getFilesListOfBuild(
    buildLocator: string,
    basePath?: string,
    locator?: string,
    fields?: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getFilesListOfBuild(
        buildLocator,
        basePath,
        locator,
        fields,
        resolveParameters,
        logBuildUsage,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get multiple builds matching the locator.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getMultipleBuilds(buildLocator: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .getMultipleBuilds(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get specific file zipped.
   * @param {string} path
   * @param {string} buildLocator
   * @param {string} [basePath]
   * @param {string} [locator]
   * @param {string} [name]
   * @param {boolean} [resolveParameters]
   * @param {boolean} [logBuildUsage]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public getZippedFileOfBuild(
    path: string,
    buildLocator: string,
    basePath?: string,
    locator?: string,
    name?: string,
    resolveParameters?: boolean,
    logBuildUsage?: boolean,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .getZippedFileOfBuild(
        path,
        buildLocator,
        basePath,
        locator,
        name,
        resolveParameters,
        logBuildUsage,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Starts the queued build as an agent-less build and returns the corresponding running build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public markBuildAsRunning(
    buildLocator: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .markBuildAsRunning(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Pin multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {PinInfo} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public pinMultipleBuilds(
    buildLocator: string,
    fields?: string,
    body?: PinInfo,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .pinMultipleBuilds(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove tags from multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public removeMultipleBuildTags(
    buildLocator: string,
    fields?: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .removeMultipleBuildTags(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove build parameters from the matching build.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public resetBuildFinishProperties(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .resetBuildFinishProperties(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the comment on the matching build.
   * @param {string} buildLocator
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public setBuildComment(buildLocator: string, body?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .setBuildComment(buildLocator, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Marks the running build as finished by passing agent the current time of the build to finish.
   * @param {string} buildLocator
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public setBuildFinishDate(buildLocator: string, body?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .setBuildFinishDate(buildLocator, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the number of the matching build.
   * @param {string} buildLocator
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public setBuildNumber(buildLocator: string, body?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .setBuildNumber(buildLocator, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the pin info of the matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {PinInfo} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public setBuildPinInfo(
    buildLocator: string,
    fields?: string,
    body?: PinInfo,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .setBuildPinInfo(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Change status of the build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {BuildStatusUpdate} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public setBuildStatus(
    buildLocator: string,
    fields?: string,
    body?: BuildStatusUpdate,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .setBuildStatus(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the build status of the matching build.
   * @param {string} buildLocator
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public setBuildStatusText(buildLocator: string, body?: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .setBuildStatusText(buildLocator, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update tags of the matching build.
   * @param {string} buildLocator
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public setBuildTags(
    buildLocator: string,
    locator?: string,
    fields?: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .setBuildTags(buildLocator, locator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Marks the running build as finished by passing agent the current time of the build to finish.
   * @param {string} buildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public setFinishedTime(buildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildApiFp(this.configuration)
      .setFinishedTime(buildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update comments in multiple matching builds.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildApi
   */
  public setMultipleBuildComments(
    buildLocator: string,
    fields?: string,
    body?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildApiFp(this.configuration)
      .setMultipleBuildComments(buildLocator, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
