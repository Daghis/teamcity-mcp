/* tslint:disable */
/* eslint-disable */
/**
 * TeamCity REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2018.1 (current)
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import type { AxiosInstance, AxiosPromise, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';

// @ts-ignore
import {
  BASE_PATH,
  BaseAPI,
  COLLECTION_FORMATS,
  type RequestArgs,
  RequiredError,
  operationServerMap,
} from '../base';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  createRequestFunction,
  serializeDataIfNeeded,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  toPathString,
} from '../common';
import type { Configuration } from '../configuration';
// @ts-ignore
import type { Agents } from '../models';
// @ts-ignore
import type { ApprovalInfo } from '../models';
// @ts-ignore
import type { Build } from '../models';
// @ts-ignore
import type { BuildCancelRequest } from '../models';
// @ts-ignore
import type { Builds } from '../models';
// @ts-ignore
import type { Tags } from '../models';

/**
 * BuildQueueApi - axios parameter creator
 * @export
 */
export const BuildQueueApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add a new build to the queue.
     * @param {boolean} [moveToTop]
     * @param {Build} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addBuildToQueue: async (
      moveToTop?: boolean,
      body?: Build,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/buildQueue`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (moveToTop !== undefined) {
        localVarQueryParameter['moveToTop'] = String(moveToTop);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Add tags to the matching build.
     * @param {string} buildLocator
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagsToBuildOfBuildQueue: async (
      buildLocator: string,
      body?: Tags,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('addTagsToBuildOfBuildQueue', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/buildQueue/{buildLocator}/tags`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Approve queued build with approval feature enabled.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {boolean} [approveAll]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveQueuedBuild: async (
      buildLocator: string,
      fields?: string,
      approveAll?: boolean,
      body?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('approveQueuedBuild', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/buildQueue/{buildLocator}/approve`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      if (approveAll !== undefined) {
        localVarQueryParameter['approveAll'] = String(approveAll);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Cancel a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {BuildCancelRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelQueuedBuild: async (
      queuedBuildLocator: string,
      body?: BuildCancelRequest,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queuedBuildLocator' is not null or undefined
      assertParamExists('cancelQueuedBuild', 'queuedBuildLocator', queuedBuildLocator);
      const localVarPath = `/app/rest/buildQueue/{queuedBuildLocator}`.replace(
        `{${'queuedBuildLocator'}}`,
        encodeURIComponent(String(queuedBuildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete all queued builds.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllQueuedBuilds: async (
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/buildQueue`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueuedBuild: async (
      queuedBuildLocator: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queuedBuildLocator' is not null or undefined
      assertParamExists('deleteQueuedBuild', 'queuedBuildLocator', queuedBuildLocator);
      const localVarPath = `/app/rest/buildQueue/{queuedBuildLocator}`.replace(
        `{${'queuedBuildLocator'}}`,
        encodeURIComponent(String(queuedBuildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all queued builds.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllQueuedBuilds: async (
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/buildQueue`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get approval info of a queued matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApprovalInfo: async (
      buildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getApprovalInfo', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/buildQueue/{buildLocator}/approvalInfo`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get compatible agents for a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompatibleAgentsForBuild: async (
      queuedBuildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queuedBuildLocator' is not null or undefined
      assertParamExists('getCompatibleAgentsForBuild', 'queuedBuildLocator', queuedBuildLocator);
      const localVarPath = `/app/rest/buildQueue/{queuedBuildLocator}/compatibleAgents`.replace(
        `{${'queuedBuildLocator'}}`,
        encodeURIComponent(String(queuedBuildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedBuild: async (
      queuedBuildLocator: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queuedBuildLocator' is not null or undefined
      assertParamExists('getQueuedBuild', 'queuedBuildLocator', queuedBuildLocator);
      const localVarPath = `/app/rest/buildQueue/{queuedBuildLocator}`.replace(
        `{${'queuedBuildLocator'}}`,
        encodeURIComponent(String(queuedBuildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the queue position of a queued matching build.
     * @param {string} queuePosition
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedBuildPosition: async (
      queuePosition: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queuePosition' is not null or undefined
      assertParamExists('getQueuedBuildPosition', 'queuePosition', queuePosition);
      const localVarPath = `/app/rest/buildQueue/order/{queuePosition}`.replace(
        `{${'queuePosition'}}`,
        encodeURIComponent(String(queuePosition))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get tags of the queued matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedBuildTags: async (
      buildLocator: string,
      locator?: string,
      fields?: string,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'buildLocator' is not null or undefined
      assertParamExists('getQueuedBuildTags', 'buildLocator', buildLocator);
      const localVarPath = `/app/rest/buildQueue/{buildLocator}/tags`.replace(
        `{${'buildLocator'}}`,
        encodeURIComponent(String(buildLocator))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (locator !== undefined) {
        localVarQueryParameter['locator'] = String(locator);
      }

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the queue position of a queued matching build.
     * @param {string} queuePosition
     * @param {string} [fields]
     * @param {Build} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setQueuedBuildPosition: async (
      queuePosition: string,
      fields?: string,
      body?: Build,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'queuePosition' is not null or undefined
      assertParamExists('setQueuedBuildPosition', 'queuePosition', queuePosition);
      const localVarPath = `/app/rest/buildQueue/order/{queuePosition}`.replace(
        `{${'queuePosition'}}`,
        encodeURIComponent(String(queuePosition))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update the build queue order.
     * @param {string} [fields]
     * @param {Builds} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setQueuedBuildsOrder: async (
      fields?: string,
      body?: Builds,
      options: RawAxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/app/rest/buildQueue/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as Record<string, string>;
      const localVarQueryParameter = {} as Record<string, string>;

      if (fields !== undefined) {
        localVarQueryParameter['fields'] = String(fields);
      }

      localVarHeaderParameter['Content-Type'] = 'application/xml';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions["headers"] ? baseOptions["headers"] : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options["headers"],
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BuildQueueApi - functional programming interface
 * @export
 */
export const BuildQueueApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BuildQueueApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Add a new build to the queue.
     * @param {boolean} [moveToTop]
     * @param {Build} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addBuildToQueue(
      moveToTop?: boolean,
      body?: Build,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addBuildToQueue(
        moveToTop,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.addBuildToQueue']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Add tags to the matching build.
     * @param {string} buildLocator
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addTagsToBuildOfBuildQueue(
      buildLocator: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addTagsToBuildOfBuildQueue(
        buildLocator,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.addTagsToBuildOfBuildQueue']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Approve queued build with approval feature enabled.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {boolean} [approveAll]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async approveQueuedBuild(
      buildLocator: string,
      fields?: string,
      approveAll?: boolean,
      body?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.approveQueuedBuild(
        buildLocator,
        fields,
        approveAll,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.approveQueuedBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Cancel a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {BuildCancelRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async cancelQueuedBuild(
      queuedBuildLocator: string,
      body?: BuildCancelRequest,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.cancelQueuedBuild(
        queuedBuildLocator,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.cancelQueuedBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete all queued builds.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAllQueuedBuilds(
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllQueuedBuilds(
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.deleteAllQueuedBuilds']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Delete a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteQueuedBuild(
      queuedBuildLocator: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteQueuedBuild(
        queuedBuildLocator,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.deleteQueuedBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get all queued builds.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAllQueuedBuilds(
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Builds>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getAllQueuedBuilds(
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.getAllQueuedBuilds']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get approval info of a queued matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getApprovalInfo(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApprovalInfo>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getApprovalInfo(
        buildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.getApprovalInfo']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get compatible agents for a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCompatibleAgentsForBuild(
      queuedBuildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agents>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCompatibleAgentsForBuild(
        queuedBuildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.getCompatibleAgentsForBuild']?.[
          localVarOperationServerIndex
        ]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedBuild(
      queuedBuildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getQueuedBuild(
        queuedBuildLocator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.getQueuedBuild']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get the queue position of a queued matching build.
     * @param {string} queuePosition
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedBuildPosition(
      queuePosition: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getQueuedBuildPosition(
        queuePosition,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.getQueuedBuildPosition']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Get tags of the queued matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getQueuedBuildTags(
      buildLocator: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tags>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getQueuedBuildTags(
        buildLocator,
        locator,
        fields,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.getQueuedBuildTags']?.[localVarOperationServerIndex]?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update the queue position of a queued matching build.
     * @param {string} queuePosition
     * @param {string} [fields]
     * @param {Build} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setQueuedBuildPosition(
      queuePosition: string,
      fields?: string,
      body?: Build,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Build>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setQueuedBuildPosition(
        queuePosition,
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.setQueuedBuildPosition']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
    /**
     *
     * @summary Update the build queue order.
     * @param {string} [fields]
     * @param {Builds} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setQueuedBuildsOrder(
      fields?: string,
      body?: Builds,
      options?: RawAxiosRequestConfig
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Builds>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setQueuedBuildsOrder(
        fields,
        body,
        options
      );
      const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
      const localVarOperationServerBasePath =
        operationServerMap['BuildQueueApi.setQueuedBuildsOrder']?.[localVarOperationServerIndex]
          ?.url;
      return (axios, basePath) =>
        createRequestFunction(
          localVarAxiosArgs,
          globalAxios,
          BASE_PATH,
          configuration
        )(axios, localVarOperationServerBasePath || basePath);
    },
  };
};

/**
 * BuildQueueApi - factory interface
 * @export
 */
export const BuildQueueApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = BuildQueueApiFp(configuration);
  return {
    /**
     *
     * @summary Add a new build to the queue.
     * @param {boolean} [moveToTop]
     * @param {Build} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addBuildToQueue(
      moveToTop?: boolean,
      body?: Build,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Build> {
      return localVarFp
        .addBuildToQueue(moveToTop, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Add tags to the matching build.
     * @param {string} buildLocator
     * @param {Tags} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addTagsToBuildOfBuildQueue(
      buildLocator: string,
      body?: Tags,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .addTagsToBuildOfBuildQueue(buildLocator, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Approve queued build with approval feature enabled.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {boolean} [approveAll]
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    approveQueuedBuild(
      buildLocator: string,
      fields?: string,
      approveAll?: boolean,
      body?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ApprovalInfo> {
      return localVarFp
        .approveQueuedBuild(buildLocator, fields, approveAll, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Cancel a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {BuildCancelRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancelQueuedBuild(
      queuedBuildLocator: string,
      body?: BuildCancelRequest,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Build> {
      return localVarFp
        .cancelQueuedBuild(queuedBuildLocator, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete all queued builds.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAllQueuedBuilds(
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteAllQueuedBuilds(locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteQueuedBuild(
      queuedBuildLocator: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<void> {
      return localVarFp
        .deleteQueuedBuild(queuedBuildLocator, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all queued builds.
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllQueuedBuilds(
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Builds> {
      return localVarFp
        .getAllQueuedBuilds(locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get approval info of a queued matching build.
     * @param {string} buildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getApprovalInfo(
      buildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<ApprovalInfo> {
      return localVarFp
        .getApprovalInfo(buildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get compatible agents for a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCompatibleAgentsForBuild(
      queuedBuildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Agents> {
      return localVarFp
        .getCompatibleAgentsForBuild(queuedBuildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a queued matching build.
     * @param {string} queuedBuildLocator
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedBuild(
      queuedBuildLocator: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Build> {
      return localVarFp
        .getQueuedBuild(queuedBuildLocator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the queue position of a queued matching build.
     * @param {string} queuePosition
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedBuildPosition(
      queuePosition: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Build> {
      return localVarFp
        .getQueuedBuildPosition(queuePosition, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get tags of the queued matching build.
     * @param {string} buildLocator
     * @param {string} [locator]
     * @param {string} [fields]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getQueuedBuildTags(
      buildLocator: string,
      locator?: string,
      fields?: string,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Tags> {
      return localVarFp
        .getQueuedBuildTags(buildLocator, locator, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the queue position of a queued matching build.
     * @param {string} queuePosition
     * @param {string} [fields]
     * @param {Build} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setQueuedBuildPosition(
      queuePosition: string,
      fields?: string,
      body?: Build,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Build> {
      return localVarFp
        .setQueuedBuildPosition(queuePosition, fields, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update the build queue order.
     * @param {string} [fields]
     * @param {Builds} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setQueuedBuildsOrder(
      fields?: string,
      body?: Builds,
      options?: RawAxiosRequestConfig
    ): AxiosPromise<Builds> {
      return localVarFp
        .setQueuedBuildsOrder(fields, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BuildQueueApi - interface
 * @export
 * @interface BuildQueueApi
 */
export interface BuildQueueApiInterface {
  /**
   *
   * @summary Add a new build to the queue.
   * @param {boolean} [moveToTop]
   * @param {Build} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  addBuildToQueue(
    moveToTop?: boolean,
    body?: Build,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Build>;

  /**
   *
   * @summary Add tags to the matching build.
   * @param {string} buildLocator
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  addTagsToBuildOfBuildQueue(
    buildLocator: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Approve queued build with approval feature enabled.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {boolean} [approveAll]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  approveQueuedBuild(
    buildLocator: string,
    fields?: string,
    approveAll?: boolean,
    body?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ApprovalInfo>;

  /**
   *
   * @summary Cancel a queued matching build.
   * @param {string} queuedBuildLocator
   * @param {BuildCancelRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  cancelQueuedBuild(
    queuedBuildLocator: string,
    body?: BuildCancelRequest,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Build>;

  /**
   *
   * @summary Delete all queued builds.
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  deleteAllQueuedBuilds(
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Delete a queued matching build.
   * @param {string} queuedBuildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  deleteQueuedBuild(
    queuedBuildLocator: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<void>;

  /**
   *
   * @summary Get all queued builds.
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  getAllQueuedBuilds(
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Builds>;

  /**
   *
   * @summary Get approval info of a queued matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  getApprovalInfo(
    buildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<ApprovalInfo>;

  /**
   *
   * @summary Get compatible agents for a queued matching build.
   * @param {string} queuedBuildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  getCompatibleAgentsForBuild(
    queuedBuildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Agents>;

  /**
   *
   * @summary Get a queued matching build.
   * @param {string} queuedBuildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  getQueuedBuild(
    queuedBuildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Build>;

  /**
   *
   * @summary Get the queue position of a queued matching build.
   * @param {string} queuePosition
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  getQueuedBuildPosition(
    queuePosition: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Build>;

  /**
   *
   * @summary Get tags of the queued matching build.
   * @param {string} buildLocator
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  getQueuedBuildTags(
    buildLocator: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Tags>;

  /**
   *
   * @summary Update the queue position of a queued matching build.
   * @param {string} queuePosition
   * @param {string} [fields]
   * @param {Build} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  setQueuedBuildPosition(
    queuePosition: string,
    fields?: string,
    body?: Build,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Build>;

  /**
   *
   * @summary Update the build queue order.
   * @param {string} [fields]
   * @param {Builds} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApiInterface
   */
  setQueuedBuildsOrder(
    fields?: string,
    body?: Builds,
    options?: RawAxiosRequestConfig
  ): AxiosPromise<Builds>;
}

/**
 * BuildQueueApi - object-oriented interface
 * @export
 * @class BuildQueueApi
 * @extends {BaseAPI}
 */
export class BuildQueueApi extends BaseAPI implements BuildQueueApiInterface {
  /**
   *
   * @summary Add a new build to the queue.
   * @param {boolean} [moveToTop]
   * @param {Build} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public addBuildToQueue(moveToTop?: boolean, body?: Build, options?: RawAxiosRequestConfig) {
    return BuildQueueApiFp(this.configuration)
      .addBuildToQueue(moveToTop, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Add tags to the matching build.
   * @param {string} buildLocator
   * @param {Tags} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public addTagsToBuildOfBuildQueue(
    buildLocator: string,
    body?: Tags,
    options?: RawAxiosRequestConfig
  ) {
    return BuildQueueApiFp(this.configuration)
      .addTagsToBuildOfBuildQueue(buildLocator, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Approve queued build with approval feature enabled.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {boolean} [approveAll]
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public approveQueuedBuild(
    buildLocator: string,
    fields?: string,
    approveAll?: boolean,
    body?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildQueueApiFp(this.configuration)
      .approveQueuedBuild(buildLocator, fields, approveAll, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Cancel a queued matching build.
   * @param {string} queuedBuildLocator
   * @param {BuildCancelRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public cancelQueuedBuild(
    queuedBuildLocator: string,
    body?: BuildCancelRequest,
    options?: RawAxiosRequestConfig
  ) {
    return BuildQueueApiFp(this.configuration)
      .cancelQueuedBuild(queuedBuildLocator, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete all queued builds.
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public deleteAllQueuedBuilds(locator?: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildQueueApiFp(this.configuration)
      .deleteAllQueuedBuilds(locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a queued matching build.
   * @param {string} queuedBuildLocator
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public deleteQueuedBuild(queuedBuildLocator: string, options?: RawAxiosRequestConfig) {
    return BuildQueueApiFp(this.configuration)
      .deleteQueuedBuild(queuedBuildLocator, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all queued builds.
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public getAllQueuedBuilds(locator?: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildQueueApiFp(this.configuration)
      .getAllQueuedBuilds(locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get approval info of a queued matching build.
   * @param {string} buildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public getApprovalInfo(buildLocator: string, fields?: string, options?: RawAxiosRequestConfig) {
    return BuildQueueApiFp(this.configuration)
      .getApprovalInfo(buildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get compatible agents for a queued matching build.
   * @param {string} queuedBuildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public getCompatibleAgentsForBuild(
    queuedBuildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildQueueApiFp(this.configuration)
      .getCompatibleAgentsForBuild(queuedBuildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a queued matching build.
   * @param {string} queuedBuildLocator
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public getQueuedBuild(
    queuedBuildLocator: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildQueueApiFp(this.configuration)
      .getQueuedBuild(queuedBuildLocator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the queue position of a queued matching build.
   * @param {string} queuePosition
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public getQueuedBuildPosition(
    queuePosition: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildQueueApiFp(this.configuration)
      .getQueuedBuildPosition(queuePosition, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get tags of the queued matching build.
   * @param {string} buildLocator
   * @param {string} [locator]
   * @param {string} [fields]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public getQueuedBuildTags(
    buildLocator: string,
    locator?: string,
    fields?: string,
    options?: RawAxiosRequestConfig
  ) {
    return BuildQueueApiFp(this.configuration)
      .getQueuedBuildTags(buildLocator, locator, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the queue position of a queued matching build.
   * @param {string} queuePosition
   * @param {string} [fields]
   * @param {Build} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public setQueuedBuildPosition(
    queuePosition: string,
    fields?: string,
    body?: Build,
    options?: RawAxiosRequestConfig
  ) {
    return BuildQueueApiFp(this.configuration)
      .setQueuedBuildPosition(queuePosition, fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update the build queue order.
   * @param {string} [fields]
   * @param {Builds} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BuildQueueApi
   */
  public setQueuedBuildsOrder(fields?: string, body?: Builds, options?: RawAxiosRequestConfig) {
    return BuildQueueApiFp(this.configuration)
      .setQueuedBuildsOrder(fields, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
